1304332687
2 2
11 libinterval 4 SpsC 8 p3direct 
151
161 8 get_name 4 312 19 CInterval::get_name 0 1 1 732
// Filename: cInterval.I
// Created by:  drose (27Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_name
//       Access: Published
//  Description: Returns the interval's name.
////////////////////////////////////////////////////////////////////
67
inline basic_string< char > const &CInterval::get_name(void) const;

162 12 get_duration 4 312 23 CInterval::get_duration 0 1 2 271
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_duration
//       Access: Published
//  Description: Returns the duration of the interval in seconds.
////////////////////////////////////////////////////////////////////
50
inline double CInterval::get_duration(void) const;

163 14 get_open_ended 4 312 25 CInterval::get_open_ended 0 1 3 685
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_open_ended
//       Access: Published
//  Description: Returns the state of the "open_ended" flag.  This is
//               primarily intended for instantaneous intervals like
//               FunctionIntervals; it indicates true if the interval
//               has some lasting effect that should be applied even
//               if the interval doesn't get started until after its
//               finish time, or false if the interval is a transitive
//               thing that doesn't need to be called late.
////////////////////////////////////////////////////////////////////
50
inline bool CInterval::get_open_ended(void) const;

164 9 get_state 4 312 20 CInterval::get_state 0 1 4 385
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_state
//       Access: Published
//  Description: Indicates the state the interval believes it is in:
//               whether it has been started, is currently in the
//               middle, or has been finalized.
////////////////////////////////////////////////////////////////////
57
inline CInterval::State CInterval::get_state(void) const;

165 10 is_stopped 4 312 21 CInterval::is_stopped 0 1 5 364
////////////////////////////////////////////////////////////////////
//     Function: CInterval::is_stopped
//       Access: Published
//  Description: Returns true if the interval is in either its initial
//               or final states (but not in a running or paused
//               state).
////////////////////////////////////////////////////////////////////
46
inline bool CInterval::is_stopped(void) const;

166 14 set_done_event 4 312 25 CInterval::set_done_event 0 1 6 426
////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_done_event
//       Access: Published
//  Description: Sets the event that is generated whenever the
//               interval reaches its final state, whether it is
//               explicitly finished or whether it gets there on its
//               own.
////////////////////////////////////////////////////////////////////
73
inline void CInterval::set_done_event(basic_string< char > const &event);

167 14 get_done_event 4 312 25 CInterval::get_done_event 0 1 7 429
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_done_event
//       Access: Published
//  Description: Returns the event that is generated whenever the
//               interval reaches its final state, whether it is
//               explicitly finished or whether it gets there on its
//               own.
////////////////////////////////////////////////////////////////////
73
inline basic_string< char > const &CInterval::get_done_event(void) const;

168 5 set_t 4 312 16 CInterval::set_t 0 1 8 450
////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_t
//       Access: Published
//  Description: Explicitly sets the time within the interval.
//               Normally, you would use start() .. finish() to let
//               the time play normally, but this may be used to set
//               the time to some particular value.
////////////////////////////////////////////////////////////////////
32
void CInterval::set_t(double t);

169 5 get_t 4 312 16 CInterval::get_t 0 1 9 373
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_t
//       Access: Published
//  Description: Returns the current time of the interval: the last
//               value of t passed to priv_initialize(), priv_step(), or
//               priv_finalize().
////////////////////////////////////////////////////////////////////
43
inline double CInterval::get_t(void) const;

170 14 set_auto_pause 4 312 25 CInterval::set_auto_pause 0 1 10 624
////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_auto_pause
//       Access: Published
//  Description: Changes the state of the 'auto_pause' flag.  If
//               this is true, the interval may be arbitrarily
//               interrupted when the system needs to reset due to
//               some external event by calling
//               CIntervalManager::interrupt().  If this
//               is false (the default), the interval must always be
//               explicitly finished or paused.
////////////////////////////////////////////////////////////////////
55
inline void CInterval::set_auto_pause(bool auto_pause);

171 14 get_auto_pause 4 312 25 CInterval::get_auto_pause 0 1 11 308
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_auto_pause
//       Access: Published
//  Description: Returns the state of the 'auto_pause' flag.  See
//               set_auto_pause().
////////////////////////////////////////////////////////////////////
50
inline bool CInterval::get_auto_pause(void) const;

172 15 set_auto_finish 4 312 26 CInterval::set_auto_finish 0 1 12 623
////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_auto_finish
//       Access: Published
//  Description: Changes the state of the 'auto_finish' flag.  If
//               this is true, the interval may be arbitrarily
//               finished when the system needs to reset due to
//               some external event by calling
//               CIntervalManager::interrupt().  If this
//               is false (the default), the interval must always be
//               explicitly finished or paused.
////////////////////////////////////////////////////////////////////
57
inline void CInterval::set_auto_finish(bool auto_finish);

173 15 get_auto_finish 4 312 26 CInterval::get_auto_finish 0 1 13 311
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_auto_finish
//       Access: Published
//  Description: Returns the state of the 'auto_finish' flag.  See
//               set_auto_finish().
////////////////////////////////////////////////////////////////////
51
inline bool CInterval::get_auto_finish(void) const;

174 20 set_wants_t_callback 4 312 31 CInterval::set_wants_t_callback 0 1 14 533
////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_wants_t_callback
//       Access: Published
//  Description: Changes the state of the 'wants_t_callback' flag.  If
//               this is true, the interval will be returned by
//               CIntervalManager::get_event() each time the
//               interval's time value has been changed, regardless of
//               whether it has any external events.
////////////////////////////////////////////////////////////////////
67
inline void CInterval::set_wants_t_callback(bool wants_t_callback);

175 20 get_wants_t_callback 4 312 31 CInterval::get_wants_t_callback 0 1 15 325
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_wants_t_callback
//       Access: Published
//  Description: Returns the state of the 'wants_t_callback' flag.
//               See set_wants_t_callback().
////////////////////////////////////////////////////////////////////
56
inline bool CInterval::get_wants_t_callback(void) const;

176 11 set_manager 4 312 22 CInterval::set_manager 0 1 16 523
////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_manager
//       Access: Published
//  Description: Indicates the CIntervalManager object which will be
//               responsible for playing this interval.  This defaults
//               to the global CIntervalManager; you should need to
//               change this only if you have special requirements for
//               playing this interval.
////////////////////////////////////////////////////////////////////
62
inline void CInterval::set_manager(CIntervalManager *manager);

177 11 get_manager 4 312 22 CInterval::get_manager 0 1 17 604
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_manager
//       Access: Published
//  Description: Returns the CIntervalManager object which will be
//               responsible for playing this interval.  Note that
//               this can only return a C++ object; if the particular
//               CIntervalManager object has been extended in the
//               scripting language, this will return the encapsulated
//               C++ object, not the full extended object.
////////////////////////////////////////////////////////////////////
60
inline CIntervalManager *CInterval::get_manager(void) const;

178 5 start 4 312 16 CInterval::start 0 4 18 19 20 21 478
////////////////////////////////////////////////////////////////////
//     Function: CInterval::start
//       Access: Published
//  Description: Starts the interval playing by registering it with
//               the current CIntervalManager.  The interval will
//               play to the end and stop.
//
//               If end_t is less than zero, it indicates the end of
//               the interval.
////////////////////////////////////////////////////////////////////
89
void CInterval::start(double start_t = (0), double end_t = (-1), double play_rate = (1));

179 4 loop 4 312 15 CInterval::loop 0 4 22 23 24 25 587
////////////////////////////////////////////////////////////////////
//     Function: CInterval::loop
//       Access: Published
//  Description: Starts the interval playing by registering it with
//               the current CIntervalManager.  The interval will
//               play until it is interrupted with finish() or
//               pause(), looping back to start_t when it reaches
//               end_t.
//
//               If end_t is less than zero, it indicates the end of
//               the interval.
////////////////////////////////////////////////////////////////////
88
void CInterval::loop(double start_t = (0), double end_t = (-1), double play_rate = (1));

180 5 pause 4 312 16 CInterval::pause 0 1 26 379
////////////////////////////////////////////////////////////////////
//     Function: CInterval::pause
//       Access: Published
//  Description: Stops the interval from playing but leaves it in its
//               current state.  It may later be resumed from this
//               point by calling resume().
////////////////////////////////////////////////////////////////////
30
double CInterval::pause(void);

181 6 resume 4 312 17 CInterval::resume 0 2 27 28 628
////////////////////////////////////////////////////////////////////
//     Function: CInterval::resume
//       Access: Published
//  Description: Restarts the interval from its current point after a
//               previous call to pause().
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: CInterval::resume
//       Access: Published
//  Description: Restarts the interval from the indicated point after a
//               previous call to pause().
////////////////////////////////////////////////////////////////////
69
void CInterval::resume(void);
void CInterval::resume(double start_t);

182 12 resume_until 4 312 23 CInterval::resume_until 0 1 29 440
////////////////////////////////////////////////////////////////////
//     Function: CInterval::resume_until
//       Access: Published
//  Description: Restarts the interval from the current point after a
//               previous call to pause() (or a previous
//               play-to-point-and-stop), to play until the indicated
//               point and then stop.
////////////////////////////////////////////////////////////////////
43
void CInterval::resume_until(double end_t);

183 6 finish 4 312 17 CInterval::finish 0 1 30 297
////////////////////////////////////////////////////////////////////
//     Function: CInterval::finish
//       Access: Published
//  Description: Stops the interval from playing and sets it to its
//               final state.
////////////////////////////////////////////////////////////////////
29
void CInterval::finish(void);

184 16 clear_to_initial 4 312 27 CInterval::clear_to_initial 0 1 31 551
////////////////////////////////////////////////////////////////////
//     Function: CInterval::clear_to_initial
//       Access: Published
//  Description: Pauses the interval, if it is playing, and resets its
//               state to its initial state, abandoning any state
//               changes already in progress in the middle of the
//               interval.  Calling this is like pausing the interval
//               and discarding it, creating a new one in its place.
////////////////////////////////////////////////////////////////////
39
void CInterval::clear_to_initial(void);

185 10 is_playing 4 312 21 CInterval::is_playing 0 1 32 305
////////////////////////////////////////////////////////////////////
//     Function: CInterval::is_playing
//       Access: Published
//  Description: Returns true if the interval is currently playing,
//               false otherwise.
////////////////////////////////////////////////////////////////////
39
bool CInterval::is_playing(void) const;

186 13 get_play_rate 4 312 24 CInterval::get_play_rate 0 1 33 326
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_play_rate
//       Access: Published
//  Description: Returns the play rate as set by the last call to
//               start(), loop(), or set_play_rate().
////////////////////////////////////////////////////////////////////
44
double CInterval::get_play_rate(void) const;

187 13 set_play_rate 4 312 24 CInterval::set_play_rate 0 1 34 529
////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_play_rate
//       Access: Published
//  Description: Changes the play rate of the interval.  If the
//               interval is already started, this changes its speed
//               on-the-fly.  Note that since play_rate is a parameter
//               to start() and loop(), the next call to start() or
//               loop() will reset this parameter.
////////////////////////////////////////////////////////////////////
48
void CInterval::set_play_rate(double play_rate);

188 13 priv_do_event 4 312 24 CInterval::priv_do_event 0 1 35 709
// These functions control the actual playback of the interval.
// Don't call them directly; they're intended to be called from a
// supervising object, e.g. the Python start() .. finish()
// interface.
// These cannot be declared private because they must be accessible
// to Python, but the method names are prefixed with priv_ to remind
// you that you probably don't want to be using them directly.

////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_do_event
//       Access: Published
//  Description: Calls the appropriate event function indicated by the
//               EventType.
////////////////////////////////////////////////////////////////////
68
void CInterval::priv_do_event(double t, CInterval::EventType event);

189 15 priv_initialize 4 312 26 CInterval::priv_initialize 0 1 36 889
// These functions control the actual playback of the interval.
// Don't call them directly; they're intended to be called from a
// supervising object, e.g. the Python start() .. finish()
// interface.
// These cannot be declared private because they must be accessible
// to Python, but the method names are prefixed with priv_ to remind
// you that you probably don't want to be using them directly.

////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_initialize
//       Access: Published, Virtual
//  Description: This replaces the first call to priv_step(), and indicates
//               that the interval has just begun.  This may be
//               overridden by derived classes that need to do some
//               explicit initialization on the first call.
////////////////////////////////////////////////////////////////////
50
virtual void CInterval::priv_initialize(double t);

190 12 priv_instant 4 312 23 CInterval::priv_instant 0 1 37 486
////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_instant
//       Access: Published, Virtual
//  Description: This is called in lieu of priv_initialize() .. priv_step()
//               .. priv_finalize(), when everything is to happen within
//               one frame.  The interval should initialize itself,
//               then leave itself in the final state.
////////////////////////////////////////////////////////////////////
43
virtual void CInterval::priv_instant(void);

191 9 priv_step 4 312 20 CInterval::priv_step 0 1 38 409
////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_step
//       Access: Published, Virtual
//  Description: Advances the time on the interval.  The time may
//               either increase (the normal case) or decrease
//               (e.g. if the interval is being played by a slider).
////////////////////////////////////////////////////////////////////
44
virtual void CInterval::priv_step(double t);

192 13 priv_finalize 4 312 24 CInterval::priv_finalize 0 1 39 439
////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_finalize
//       Access: Published, Virtual
//  Description: This is called to stop an interval, forcing it to
//               whatever state it would be after it played all the
//               way through.  It's generally invoked by
//               set_final_t().
////////////////////////////////////////////////////////////////////
44
virtual void CInterval::priv_finalize(void);

193 23 priv_reverse_initialize 4 312 34 CInterval::priv_reverse_initialize 0 1 40 485
////////////////////////////////////////////////////////////////////
//     Function: CInterval::reverse_initialize
//       Access: Published, Virtual
//  Description: Similar to priv_initialize(), but this is called when the
//               interval is being played backwards; it indicates that
//               the interval should start at the finishing state and
//               undo any intervening intervals.
////////////////////////////////////////////////////////////////////
58
virtual void CInterval::priv_reverse_initialize(double t);

194 20 priv_reverse_instant 4 312 31 CInterval::priv_reverse_instant 0 1 41 524
////////////////////////////////////////////////////////////////////
//     Function: CInterval::reverse_instant
//       Access: Published, Virtual
//  Description: This is called in lieu of priv_reverse_initialize()
//               .. priv_step() .. priv_reverse_finalize(), when everything is
//               to happen within one frame.  The interval should
//               initialize itself, then leave itself in the initial
//               state.
////////////////////////////////////////////////////////////////////
51
virtual void CInterval::priv_reverse_instant(void);

195 21 priv_reverse_finalize 4 312 32 CInterval::priv_reverse_finalize 0 1 42 393
////////////////////////////////////////////////////////////////////
//     Function: CInterval::reverse_finalize
//       Access: Published, Virtual
//  Description: Called generally following a priv_reverse_initialize(),
//               this indicates the interval should set itself to the
//               initial state.
////////////////////////////////////////////////////////////////////
52
virtual void CInterval::priv_reverse_finalize(void);

196 14 priv_interrupt 4 312 25 CInterval::priv_interrupt 0 1 43 812
////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_interrupt
//       Access: Published, Virtual
//  Description: This is called while the interval is playing to
//               indicate that it is about to be interrupted; that is,
//               priv_step() will not be called for a length of time.  But
//               the interval should remain in its current state in
//               anticipation of being eventually restarted when the
//               calls to priv_step() eventually resume.
//
//               The purpose of this function is to allow self-running
//               intervals like sound intervals to stop the actual
//               sound playback during the pause.
////////////////////////////////////////////////////////////////////
45
virtual void CInterval::priv_interrupt(void);

197 6 output 4 312 17 CInterval::output 0 1 44 226
////////////////////////////////////////////////////////////////////
//     Function: CInterval::output
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
51
virtual void CInterval::output(ostream &out) const;

198 5 write 4 312 16 CInterval::write 0 1 45 225
////////////////////////////////////////////////////////////////////
//     Function: CInterval::write
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
68
virtual void CInterval::write(ostream &out, int indent_level) const;

199 10 setup_play 4 312 21 CInterval::setup_play 0 1 46 831
////////////////////////////////////////////////////////////////////
//     Function: CInterval::setup_play
//       Access: Published
//  Description: Called to prepare the interval for automatic timed
//               playback, e.g. via a Python task.  The interval will
//               be played from start_t to end_t, at a time factor
//               specified by play_rate.  start_t must always be less
//               than end_t (except for the exception for end_t == -1,
//               below), but if play_rate is negative the interval
//               will be played backwards.
//
//               Specify end_t of -1 to play the entire interval from
//               start_t.
//
//               Call step_play() repeatedly to execute the interval.
////////////////////////////////////////////////////////////////////
95
void CInterval::setup_play(double start_time, double end_time, double play_rate, bool do_loop);

200 12 setup_resume 4 312 23 CInterval::setup_resume 0 1 47 366
////////////////////////////////////////////////////////////////////
//     Function: CInterval::setup_resume
//       Access: Published
//  Description: Called to prepare the interval for restarting at the
//               current point within the interval after an
//               interruption.
////////////////////////////////////////////////////////////////////
35
void CInterval::setup_resume(void);

201 18 setup_resume_until 4 312 29 CInterval::setup_resume_until 0 1 48 470
////////////////////////////////////////////////////////////////////
//     Function: CInterval::setup_resume_until
//       Access: Published
//  Description: Called to prepare the interval for restarting from
//               the current point after a previous call to pause()
//               (or a previous play-to-point-and-stop), to play until
//               the indicated point and then stop.
////////////////////////////////////////////////////////////////////
49
void CInterval::setup_resume_until(double end_t);

202 9 step_play 4 312 20 CInterval::step_play 0 1 49 453
////////////////////////////////////////////////////////////////////
//     Function: CInterval::step_play
//       Access: Published
//  Description: Should be called once per frame to execute the
//               automatic timed playback begun with setup_play().
//
//               Returns true if the interval should continue, false
//               if it is done and should stop.
////////////////////////////////////////////////////////////////////
32
bool CInterval::step_play(void);

203 14 get_class_type 4 312 25 CInterval::get_class_type 0 1 50 0
50
static TypeHandle CInterval::get_class_type(void);

204 18 get_bogus_variable 20 316 39 CConstraintInterval::get_bogus_variable 0 1 52 52
getter for bool CConstraintInterval::bogus_variable;
57
bool CConstraintInterval::get_bogus_variable(void) const;

205 18 set_bogus_variable 36 316 39 CConstraintInterval::set_bogus_variable 0 1 53 52
setter for bool CConstraintInterval::bogus_variable;
57
void CConstraintInterval::set_bogus_variable(bool value);

206 14 get_class_type 4 316 35 CConstraintInterval::get_class_type 0 1 51 0
60
static TypeHandle CConstraintInterval::get_class_type(void);

207 20 ~CConstraintInterval 4 316 41 CConstraintInterval::~CConstraintInterval 0 0 0
48
CConstraintInterval::~CConstraintInterval(void);

208 21 CConstrainHprInterval 4 318 44 CConstrainHprInterval::CConstrainHprInterval 0 2 54 55 682
////////////////////////////////////////////////////////////////////
//     Function: CConstrainHprInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the orientation of one node to the orientation of
//               another, possibly with an added rotation.
//
//               If wrt is true, the node's orientation will be
//               transformed into the target node's parent's  space
//               before being copied.  If wrt is false, the target
//               node's local orientation will be copied unaltered.
////////////////////////////////////////////////////////////////////
193
CConstrainHprInterval::CConstrainHprInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3f const hprOffset = ((zero())));

209 8 get_node 4 318 31 CConstrainHprInterval::get_node 0 1 56 754
// Filename: cConstrainHprInterval.I
// Created by:  pratt (10Mar08)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CConstrainHprInterval::get_node
//       Access: Published
//  Description: Returns the "source" node.
////////////////////////////////////////////////////////////////////
67
inline NodePath const &CConstrainHprInterval::get_node(void) const;

210 10 get_target 4 318 33 CConstrainHprInterval::get_target 0 1 57 259
////////////////////////////////////////////////////////////////////
//     Function: CConstrainHprInterval::get_target
//       Access: Published
//  Description: Returns the "target" node.
////////////////////////////////////////////////////////////////////
69
inline NodePath const &CConstrainHprInterval::get_target(void) const;

211 14 get_class_type 4 318 37 CConstrainHprInterval::get_class_type 0 1 58 0
62
static TypeHandle CConstrainHprInterval::get_class_type(void);

212 22 ~CConstrainHprInterval 4 318 45 CConstrainHprInterval::~CConstrainHprInterval 0 0 0
52
CConstrainHprInterval::~CConstrainHprInterval(void);

213 24 CConstrainPosHprInterval 4 319 50 CConstrainPosHprInterval::CConstrainPosHprInterval 0 3 59 60 61 720
////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosHprInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the position and orientation of one node to the
//               position and orientation of another.
//
//               If wrt is true, the node's position and orientation
//               will be transformed into the target node's parent's
//               space before being copied.  If wrt is false, the
//               target node's local position and orientation will be
//               copied unaltered.
////////////////////////////////////////////////////////////////////
240
CConstrainPosHprInterval::CConstrainPosHprInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3f const posOffset = ((zero())), LVecBase3f const hprOffset = ((zero())));

214 8 get_node 4 319 34 CConstrainPosHprInterval::get_node 0 1 62 760
// Filename: cConstrainPosHprInterval.I
// Created by:  pratt (10Mar08)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosHprInterval::get_node
//       Access: Published
//  Description: Returns the "source" node.
////////////////////////////////////////////////////////////////////
70
inline NodePath const &CConstrainPosHprInterval::get_node(void) const;

215 10 get_target 4 319 36 CConstrainPosHprInterval::get_target 0 1 63 262
////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosHprInterval::get_target
//       Access: Published
//  Description: Returns the "target" node.
////////////////////////////////////////////////////////////////////
72
inline NodePath const &CConstrainPosHprInterval::get_target(void) const;

216 14 get_class_type 4 319 40 CConstrainPosHprInterval::get_class_type 0 1 64 0
65
static TypeHandle CConstrainPosHprInterval::get_class_type(void);

217 25 ~CConstrainPosHprInterval 4 319 51 CConstrainPosHprInterval::~CConstrainPosHprInterval 0 0 0
58
CConstrainPosHprInterval::~CConstrainPosHprInterval(void);

218 21 CConstrainPosInterval 4 320 44 CConstrainPosInterval::CConstrainPosInterval 0 2 65 66 620
////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the position of one node to the position of another.
//
//               If wrt is true, the node's position will be
//               transformed into the target node's parent's  space
//               before being copied.  If wrt is false, the target
//               node's local position will be copied unaltered.
////////////////////////////////////////////////////////////////////
193
CConstrainPosInterval::CConstrainPosInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3f const posOffset = ((zero())));

219 8 get_node 4 320 31 CConstrainPosInterval::get_node 0 1 67 754
// Filename: cConstrainPosInterval.I
// Created by:  pratt (29Sep06)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosInterval::get_node
//       Access: Published
//  Description: Returns the "source" node.
////////////////////////////////////////////////////////////////////
67
inline NodePath const &CConstrainPosInterval::get_node(void) const;

220 10 get_target 4 320 33 CConstrainPosInterval::get_target 0 1 68 259
////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosInterval::get_target
//       Access: Published
//  Description: Returns the "target" node.
////////////////////////////////////////////////////////////////////
69
inline NodePath const &CConstrainPosInterval::get_target(void) const;

221 14 get_class_type 4 320 37 CConstrainPosInterval::get_class_type 0 1 69 0
62
static TypeHandle CConstrainPosInterval::get_class_type(void);

222 22 ~CConstrainPosInterval 4 320 45 CConstrainPosInterval::~CConstrainPosInterval 0 0 0
52
CConstrainPosInterval::~CConstrainPosInterval(void);

223 27 CConstrainTransformInterval 4 321 56 CConstrainTransformInterval::CConstrainTransformInterval 0 1 70 700
////////////////////////////////////////////////////////////////////
//     Function: CConstrainTransformInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the transform of one node to the transform of another.
//               To clarify, the transform of node will be copied to target.
//
//               If wrt is true, the node's transform will be
//               transformed into the target node's parent's  space
//               before being copied.  If wrt is false, the node's
//               local transform will be copied unaltered.
////////////////////////////////////////////////////////////////////
164
CConstrainTransformInterval::CConstrainTransformInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt);

224 8 get_node 4 321 37 CConstrainTransformInterval::get_node 0 1 71 766
// Filename: cConstrainTransformInterval.I
// Created by:  pratt (29Sep06)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CConstrainTransformInterval::get_node
//       Access: Published
//  Description: Returns the "source" node.
////////////////////////////////////////////////////////////////////
73
inline NodePath const &CConstrainTransformInterval::get_node(void) const;

225 10 get_target 4 321 39 CConstrainTransformInterval::get_target 0 1 72 265
////////////////////////////////////////////////////////////////////
//     Function: CConstrainTransformInterval::get_target
//       Access: Published
//  Description: Returns the "target" node.
////////////////////////////////////////////////////////////////////
75
inline NodePath const &CConstrainTransformInterval::get_target(void) const;

226 14 get_class_type 4 321 43 CConstrainTransformInterval::get_class_type 0 1 73 0
68
static TypeHandle CConstrainTransformInterval::get_class_type(void);

227 28 ~CConstrainTransformInterval 4 321 57 CConstrainTransformInterval::~CConstrainTransformInterval 0 0 0
64
CConstrainTransformInterval::~CConstrainTransformInterval(void);

228 16 CIntervalManager 4 322 34 CIntervalManager::CIntervalManager 0 1 74 229
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
41
CIntervalManager::CIntervalManager(void);

229 17 ~CIntervalManager 4 322 35 CIntervalManager::~CIntervalManager 0 0 228
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::Destructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
42
CIntervalManager::~CIntervalManager(void);

230 15 set_event_queue 4 322 33 CIntervalManager::set_event_queue 0 1 75 1195
// Filename: cIntervalManager.I
// Created by:  drose (10Sep02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::set_event_queue
//       Access: Published
//  Description: Specifies a custom event queue to be used for
//               throwing done events from intervals as they finish.
//               If this is not specified, the global event queue is
//               used.
//
//               The caller maintains ownership of the EventQueue
//               object; it is the caller's responsibility to ensure
//               that the supplied EventQueue does not destruct during
//               the lifetime of the CIntervalManager.
////////////////////////////////////////////////////////////////////
71
inline void CIntervalManager::set_event_queue(EventQueue *event_queue);

231 15 get_event_queue 4 322 33 CIntervalManager::get_event_queue 0 1 76 347
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_event_queue
//       Access: Published
//  Description: Returns the custom event queue to be used for
//               throwing done events from intervals as they finish.
////////////////////////////////////////////////////////////////////
65
inline EventQueue *CIntervalManager::get_event_queue(void) const;

232 14 add_c_interval 4 322 32 CIntervalManager::add_c_interval 0 1 77 1079
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::add_c_interval
//       Access: Published
//  Description: Adds the interval to the manager, and returns a
//               unique index for the interval.  This index will be
//               unique among all the currently added intervals, but
//               not unique across all intervals ever added to the
//               manager.  The maximum index value will never exceed
//               the maximum number of intervals added at any given
//               time.
//
//               If the external flag is true, the interval is
//               understood to also be stored in the scripting
//               language data structures.  In this case, it will be
//               available for information returned by
//               get_next_event() and get_next_removal().  If external
//               is false, the interval's index will never be returned
//               by these two functions.
////////////////////////////////////////////////////////////////////
73
int CIntervalManager::add_c_interval(CInterval *interval, bool external);

233 15 find_c_interval 4 322 33 CIntervalManager::find_c_interval 0 1 78 356
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::find_c_interval
//       Access: Published
//  Description: Returns the index associated with the named interval,
//               if there is such an interval, or -1 if there is not.
////////////////////////////////////////////////////////////////////
78
int CIntervalManager::find_c_interval(basic_string< char > const &name) const;

234 14 get_c_interval 4 322 32 CIntervalManager::get_c_interval 0 1 79 285
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_c_interval
//       Access: Published
//  Description: Returns the interval associated with the given index.
////////////////////////////////////////////////////////////////////
61
CInterval *CIntervalManager::get_c_interval(int index) const;

235 17 remove_c_interval 4 322 35 CIntervalManager::remove_c_interval 0 1 80 472
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::remove_c_interval
//       Access: Published
//  Description: Removes the indicated interval from the queue
//               immediately.  It will not be returned from
//               get_next_removal(), and none of its pending events,
//               if any, will be returned by get_next_event().
////////////////////////////////////////////////////////////////////
52
void CIntervalManager::remove_c_interval(int index);

236 9 interrupt 4 322 27 CIntervalManager::interrupt 0 1 81 605
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::interrupt
//       Access: Published
//  Description: Pauses or finishes (removes from the active queue)
//               all intervals tagged with auto_pause or auto_finish
//               set to true.  These are intervals that someone fired
//               up but won't necessarily expect to clean up; they can
//               be interrupted at will when necessary.
//
//               Returns the number of intervals affected.
////////////////////////////////////////////////////////////////////
38
int CIntervalManager::interrupt(void);

237 17 get_num_intervals 4 322 35 CIntervalManager::get_num_intervals 0 1 82 284
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_num_intervals
//       Access: Published
//  Description: Returns the number of currently active intervals.
////////////////////////////////////////////////////////////////////
52
int CIntervalManager::get_num_intervals(void) const;

238 13 get_max_index 4 322 31 CIntervalManager::get_max_index 0 1 83 591
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_max_index
//       Access: Published
//  Description: Returns one more than the largest interval index
//               number in the manager.  If you walk through all the
//               values between (0, get_max_index()] and call
//               get_c_interval() on each number, you will retrieve
//               all of the managed intervals (and possibly a number
//               of NULL pointers as well).
////////////////////////////////////////////////////////////////////
48
int CIntervalManager::get_max_index(void) const;

239 4 step 4 322 22 CIntervalManager::step 0 1 84 771
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::step
//       Access: Published
//  Description: This should be called every frame to do the
//               processing for all the active intervals.  It will
//               call step_play() for each interval that has been
//               added and that has not yet been removed.
//
//               After each call to step(), the scripting language
//               should call get_next_event() and get_next_removal()
//               repeatedly to process all the high-level
//               (e.g. Python-interval-based) events and to manage the
//               high-level list of intervals.
////////////////////////////////////////////////////////////////////
34
void CIntervalManager::step(void);

240 14 get_next_event 4 322 32 CIntervalManager::get_next_event 0 1 85 911
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_next_event
//       Access: Published
//  Description: This should be called by the scripting language after
//               each call to step().  It returns the index number of
//               the next interval that has events requiring servicing
//               by the scripting language, or -1 if no more intervals
//               have any events pending.
//
//               If this function returns something other than -1, it
//               is the scripting language's responsibility to query
//               the indicated interval for its next event via
//               get_event_index(), and eventually pop_event().
//
//               Then get_next_event() should be called again until it
//               returns -1.
////////////////////////////////////////////////////////////////////
43
int CIntervalManager::get_next_event(void);

241 16 get_next_removal 4 322 34 CIntervalManager::get_next_removal 0 1 86 694
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_next_removal
//       Access: Published
//  Description: This should be called by the scripting language after
//               each call to step().  It returns the index number of
//               an interval that was recently removed, or -1 if no
//               intervals were removed.
//
//               If this returns something other than -1, the
//               scripting language should clean up its own data
//               structures accordingly, and then call
//               get_next_removal() again.
////////////////////////////////////////////////////////////////////
45
int CIntervalManager::get_next_removal(void);

242 6 output 4 322 24 CIntervalManager::output 0 1 87 224
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
50
void CIntervalManager::output(ostream &out) const;

243 5 write 4 322 23 CIntervalManager::write 0 1 88 223
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::write
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
49
void CIntervalManager::write(ostream &out) const;

244 14 get_global_ptr 4 322 32 CIntervalManager::get_global_ptr 0 1 89 319
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_global_ptr
//       Access: Published, Static
//  Description: Returns the pointer to the one global
//               CIntervalManager object.
////////////////////////////////////////////////////////////////////
64
static CIntervalManager *CIntervalManager::get_global_ptr(void);

245 14 get_blend_type 4 323 29 CLerpInterval::get_blend_type 0 1 90 411
////////////////////////////////////////////////////////////////////
//     Function: CLerpInterval::get_blend_type
//       Access: Published
//  Description: Returns the blend type specified for the interval.
//               This controls how the linear interpolation behaves
//               near the beginning and end of the lerp period.
////////////////////////////////////////////////////////////////////
74
inline CLerpInterval::BlendType CLerpInterval::get_blend_type(void) const;

246 17 string_blend_type 4 323 32 CLerpInterval::string_blend_type 0 1 91 403
////////////////////////////////////////////////////////////////////
//     Function: CLerpInterval::string_blend_type
//       Access: Published, Static
//  Description: Returns the BlendType enumerated value corresponding
//               to the indicated string, or BT_invalid if the string
//               doesn't match anything.
////////////////////////////////////////////////////////////////////
105
static CLerpInterval::BlendType CLerpInterval::string_blend_type(basic_string< char > const &blend_type);

247 14 get_class_type 4 323 29 CLerpInterval::get_class_type 0 1 92 0
54
static TypeHandle CLerpInterval::get_class_type(void);

248 14 ~CLerpInterval 4 323 29 CLerpInterval::~CLerpInterval 0 0 0
36
CLerpInterval::~CLerpInterval(void);

249 23 CLerpAnimEffectInterval 4 325 48 CLerpAnimEffectInterval::CLerpAnimEffectInterval 0 1 93 735
// Filename: cLerpAnimEffectInterval.I
// Created by:  drose (27Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CLerpAnimEffectInterval::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
144
inline CLerpAnimEffectInterval::CLerpAnimEffectInterval(basic_string< char > const &name, double duration, CLerpInterval::BlendType blend_type);

250 11 add_control 4 325 36 CLerpAnimEffectInterval::add_control 0 1 94 573
////////////////////////////////////////////////////////////////////
//     Function: CLerpAnimEffectInterval::add_control
//       Access: Published
//  Description: Adds another AnimControl to the list of AnimControls
//               affected by the lerp.  This control will be lerped
//               from begin_effect to end_effect over the period of
//               the lerp.
//
//               The AnimControl name parameter is only used when
//               formatting the interval for output.
////////////////////////////////////////////////////////////////////
143
inline void CLerpAnimEffectInterval::add_control(AnimControl *control, basic_string< char > const &name, float begin_effect, float end_effect);

251 14 get_class_type 4 325 39 CLerpAnimEffectInterval::get_class_type 0 1 95 0
64
static TypeHandle CLerpAnimEffectInterval::get_class_type(void);

252 24 ~CLerpAnimEffectInterval 4 325 49 CLerpAnimEffectInterval::~CLerpAnimEffectInterval 0 0 0
56
CLerpAnimEffectInterval::~CLerpAnimEffectInterval(void);

253 21 CLerpNodePathInterval 4 326 44 CLerpNodePathInterval::CLerpNodePathInterval 0 1 96 1792
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::Constructor
//       Access: Published
//  Description: Constructs a lerp interval that will lerp some
//               properties on the indicated node, possibly relative
//               to the indicated other node (if other is nonempty).
//
//               You must call set_end_pos(), etc. for the various
//               properties you wish to lerp before the first call to
//               priv_initialize().  If you want to set a starting value
//               for any of the properties, you may call
//               set_start_pos(), etc.; otherwise, the starting value
//               is taken from the actual node's value at the time the
//               lerp is performed.
//
//               The starting values may be explicitly specified or
//               omitted.  The value of bake_in_start determines the
//               behavior if the starting values are omitted.  If
//               bake_in_start is true, the values are obtained the
//               first time the lerp runs, and thenceforth are stored
//               within the interval.  If bake_in_start is false, the
//               starting value is computed each frame, based on
//               assuming the current value represents the value set
//               from the last time the interval was run.  This
//               "smart" behavior allows code to manipulate the object
//               event while it is being lerped, and the lerp
//               continues to apply in a sensible way.
//
//               If fluid is true, the prev_transform is not adjusted
//               by the lerp; otherwise, it is reset.
////////////////////////////////////////////////////////////////////
210
CLerpNodePathInterval::CLerpNodePathInterval(basic_string< char > const &name, double duration, CLerpInterval::BlendType blend_type, bool bake_in_start, bool fluid, NodePath const &node, NodePath const &other);

254 8 get_node 4 326 31 CLerpNodePathInterval::get_node 0 1 97 758
// Filename: cLerpNodePathInterval.I
// Created by:  drose (27Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::get_node
//       Access: Published
//  Description: Returns the node being lerped.
////////////////////////////////////////////////////////////////////
67
inline NodePath const &CLerpNodePathInterval::get_node(void) const;

255 9 get_other 4 326 32 CLerpNodePathInterval::get_other 0 1 98 451
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::get_other
//       Access: Published
//  Description: Returns the "other" node, which the lerped node is
//               being moved relative to.  If this is an empty node
//               path, the lerped node is being moved in its own
//               coordinate system.
////////////////////////////////////////////////////////////////////
68
inline NodePath const &CLerpNodePathInterval::get_other(void) const;

256 13 set_start_pos 4 326 36 CLerpNodePathInterval::set_start_pos 0 1 99 547
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_pos
//       Access: Published
//  Description: Indicates the initial position of the lerped node.
//               This is meaningful only if set_end_pos() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               position at the time the lerp is performed.
////////////////////////////////////////////////////////////////////
72
inline void CLerpNodePathInterval::set_start_pos(LVecBase3f const &pos);

257 11 set_end_pos 4 326 34 CLerpNodePathInterval::set_end_pos 0 1 100 531
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_pos
//       Access: Published
//  Description: Indicates that the position of the node should be
//               lerped, and specifies the final position of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's position will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////
70
inline void CLerpNodePathInterval::set_end_pos(LVecBase3f const &pos);

258 13 set_start_hpr 4 326 36 CLerpNodePathInterval::set_start_hpr 0 1 101 589
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_hpr
//       Access: Published
//  Description: Indicates the initial rotation of the lerped node.
//               This is meaningful only if either set_end_hpr() or
//               set_end_quat() is also called.  This parameter is
//               optional; if unspecified, the value will be taken
//               from the node's actual rotation at the time the lerp
//               is performed.
////////////////////////////////////////////////////////////////////
72
inline void CLerpNodePathInterval::set_start_hpr(LVecBase3f const &hpr);

259 11 set_end_hpr 4 326 34 CLerpNodePathInterval::set_end_hpr 0 2 102 103 1369
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_hpr
//       Access: Published
//  Description: Indicates that the rotation of the node should be
//               lerped, and specifies the final rotation of the node.
//               This should be called before priv_initialize().
//
//               This replaces a previous call to set_end_quat().  If
//               neither set_end_hpr() nor set_end_quat() is called,
//               the node's rotation will not be affected by the lerp.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_hpr
//       Access: Published
//  Description: Indicates that the rotation of the node should be
//               lerped, and specifies the final rotation of the node.
//               This should be called before priv_initialize().
//
//               This special function is overloaded to accept a
//               quaternion, even though the function name is
//               set_end_hpr().  The quaternion will be implicitly
//               converted to a HPR trio, and the lerp will be
//               performed in HPR space, componentwise.
////////////////////////////////////////////////////////////////////
144
inline void CLerpNodePathInterval::set_end_hpr(LVecBase3f const &hpr);
inline void CLerpNodePathInterval::set_end_hpr(LQuaternionf const &quat);

260 14 set_start_quat 4 326 37 CLerpNodePathInterval::set_start_quat 0 1 104 590
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_quat
//       Access: Published
//  Description: Indicates the initial rotation of the lerped node.
//               This is meaningful only if either set_end_quat() or
//               set_end_hpr() is also called.  This parameter is
//               optional; if unspecified, the value will be taken
//               from the node's actual rotation at the time the lerp
//               is performed.
////////////////////////////////////////////////////////////////////
76
inline void CLerpNodePathInterval::set_start_quat(LQuaternionf const &quat);

261 12 set_end_quat 4 326 35 CLerpNodePathInterval::set_end_quat 0 2 105 106 1589
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_quat
//       Access: Published
//  Description: Indicates that the rotation of the node should be
//               lerped, and specifies the final rotation of the node.
//               This should be called before priv_initialize().
//
//               This replaces a previous call to set_end_hpr().  If
//               neither set_end_quat() nor set_end_hpr() is called,
//               the node's rotation will not be affected by the lerp.
//
//               This special function is overloaded to accept a HPR
//               trio, even though the function name is
//               set_end_quat().  The HPR will be implicitly converted
//               to a quaternion, and the lerp will be performed in
//               quaternion space, as a spherical lerp.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_quat
//       Access: Published
//  Description: Indicates that the rotation of the node should be
//               lerped, and specifies the final rotation of the node.
//               This should be called before priv_initialize().
//
//               This replaces a previous call to set_end_hpr().  If
//               neither set_end_quat() nor set_end_hpr() is called,
//               the node's rotation will not be affected by the lerp.
////////////////////////////////////////////////////////////////////
146
inline void CLerpNodePathInterval::set_end_quat(LVecBase3f const &hpr);
inline void CLerpNodePathInterval::set_end_quat(LQuaternionf const &quat);

262 15 set_start_scale 4 326 38 CLerpNodePathInterval::set_start_scale 0 2 107 108 1092
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_scale
//       Access: Published
//  Description: Indicates the initial scale of the lerped node.
//               This is meaningful only if set_end_scale() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               scale at the time the lerp is performed.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_scale
//       Access: Published
//  Description: Indicates the initial scale of the lerped node.
//               This is meaningful only if set_end_scale() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               scale at the time the lerp is performed.
////////////////////////////////////////////////////////////////////
141
inline void CLerpNodePathInterval::set_start_scale(LVecBase3f const &scale);
inline void CLerpNodePathInterval::set_start_scale(float scale);

263 13 set_end_scale 4 326 36 CLerpNodePathInterval::set_end_scale 0 2 109 110 1050
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_scale
//       Access: Published
//  Description: Indicates that the scale of the node should be
//               lerped, and specifies the final scale of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's scale will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_scale
//       Access: Published
//  Description: Indicates that the scale of the node should be
//               lerped, and specifies the final scale of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's scale will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////
137
inline void CLerpNodePathInterval::set_end_scale(LVecBase3f const &scale);
inline void CLerpNodePathInterval::set_end_scale(float scale);

264 15 set_start_shear 4 326 38 CLerpNodePathInterval::set_start_shear 0 1 111 545
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_shear
//       Access: Published
//  Description: Indicates the initial shear of the lerped node.
//               This is meaningful only if set_end_shear() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               shear at the time the lerp is performed.
////////////////////////////////////////////////////////////////////
76
inline void CLerpNodePathInterval::set_start_shear(LVecBase3f const &shear);

265 13 set_end_shear 4 326 36 CLerpNodePathInterval::set_end_shear 0 1 112 524
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_shear
//       Access: Published
//  Description: Indicates that the shear of the node should be
//               lerped, and specifies the final shear of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's shear will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////
74
inline void CLerpNodePathInterval::set_end_shear(LVecBase3f const &shear);

266 15 set_start_color 4 326 38 CLerpNodePathInterval::set_start_color 0 1 113 545
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_color
//       Access: Published
//  Description: Indicates the initial color of the lerped node.
//               This is meaningful only if set_end_color() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               color at the time the lerp is performed.
////////////////////////////////////////////////////////////////////
76
inline void CLerpNodePathInterval::set_start_color(LVecBase4f const &color);

267 13 set_end_color 4 326 36 CLerpNodePathInterval::set_end_color 0 1 114 524
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_color
//       Access: Published
//  Description: Indicates that the color of the node should be
//               lerped, and specifies the final color of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's color will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////
74
inline void CLerpNodePathInterval::set_end_color(LVecBase4f const &color);

268 21 set_start_color_scale 4 326 44 CLerpNodePathInterval::set_start_color_scale 0 1 115 569
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_color_scale
//       Access: Published
//  Description: Indicates the initial color scale of the lerped node.
//               This is meaningful only if set_end_color_scale() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               color scale at the time the lerp is performed.
////////////////////////////////////////////////////////////////////
88
inline void CLerpNodePathInterval::set_start_color_scale(LVecBase4f const &color_scale);

269 19 set_end_color_scale 4 326 42 CLerpNodePathInterval::set_end_color_scale 0 1 116 548
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_color_scale
//       Access: Published
//  Description: Indicates that the color scale of the node should be
//               lerped, and specifies the final color scale of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's color scale will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////
86
inline void CLerpNodePathInterval::set_end_color_scale(LVecBase4f const &color_scale);

270 17 set_texture_stage 4 326 40 CLerpNodePathInterval::set_texture_stage 0 1 117 426
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_texture_stage
//       Access: Published
//  Description: Indicates the texture stage that is adjusted by
//               tex_offset, tex_rotate, and/or tex_scale.  If this is
//               not set, the default is the default texture stage.
////////////////////////////////////////////////////////////////////
74
inline void CLerpNodePathInterval::set_texture_stage(TextureStage *stage);

271 20 set_start_tex_offset 4 326 43 CLerpNodePathInterval::set_start_tex_offset 0 1 118 563
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_tex_offset
//       Access: Published
//  Description: Indicates the initial UV offset of the lerped node.
//               This is meaningful only if set_end_tex_offset() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               UV offset at the time the lerp is performed.
////////////////////////////////////////////////////////////////////
86
inline void CLerpNodePathInterval::set_start_tex_offset(LVecBase2f const &tex_offset);

272 18 set_end_tex_offset 4 326 41 CLerpNodePathInterval::set_end_tex_offset 0 1 119 541
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_tex_offset
//       Access: Published
//  Description: Indicates that the UV offset of the node should be
//               lerped, and specifies the final UV offset of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's UV offset will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////
84
inline void CLerpNodePathInterval::set_end_tex_offset(LVecBase2f const &tex_offset);

273 20 set_start_tex_rotate 4 326 43 CLerpNodePathInterval::set_start_tex_rotate 0 1 120 563
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_tex_rotate
//       Access: Published
//  Description: Indicates the initial UV rotate of the lerped node.
//               This is meaningful only if set_end_tex_rotate() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               UV rotate at the time the lerp is performed.
////////////////////////////////////////////////////////////////////
74
inline void CLerpNodePathInterval::set_start_tex_rotate(float tex_rotate);

274 18 set_end_tex_rotate 4 326 41 CLerpNodePathInterval::set_end_tex_rotate 0 1 121 541
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_tex_rotate
//       Access: Published
//  Description: Indicates that the UV rotate of the node should be
//               lerped, and specifies the final UV rotate of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's UV rotate will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////
72
inline void CLerpNodePathInterval::set_end_tex_rotate(float tex_rotate);

275 19 set_start_tex_scale 4 326 42 CLerpNodePathInterval::set_start_tex_scale 0 1 122 559
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_tex_scale
//       Access: Published
//  Description: Indicates the initial UV scale of the lerped node.
//               This is meaningful only if set_end_tex_scale() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               UV scale at the time the lerp is performed.
////////////////////////////////////////////////////////////////////
84
inline void CLerpNodePathInterval::set_start_tex_scale(LVecBase2f const &tex_scale);

276 17 set_end_tex_scale 4 326 40 CLerpNodePathInterval::set_end_tex_scale 0 1 123 537
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_tex_scale
//       Access: Published
//  Description: Indicates that the UV scale of the node should be
//               lerped, and specifies the final UV scale of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's UV scale will not be
//               affected by the lerp.
////////////////////////////////////////////////////////////////////
82
inline void CLerpNodePathInterval::set_end_tex_scale(LVecBase2f const &tex_scale);

277 12 set_override 4 326 35 CLerpNodePathInterval::set_override 0 1 124 623
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_override
//       Access: Published
//  Description: Changes the override value that will be associated
//               with any state changes applied by the lerp.  If this
//               lerp is changing state (for instance, a color lerp or
//               a tex matrix lerp), then the new attributes created
//               by this lerp will be assigned the indicated override
//               value when they are applied to the node.
////////////////////////////////////////////////////////////////////
62
inline void CLerpNodePathInterval::set_override(int override);

278 12 get_override 4 326 35 CLerpNodePathInterval::get_override 0 1 125 384
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::get_override
//       Access: Published
//  Description: Returns the override value that will be associated
//               with any state changes applied by the lerp.  See
//               set_override().
////////////////////////////////////////////////////////////////////
59
inline int CLerpNodePathInterval::get_override(void) const;

279 14 get_class_type 4 326 37 CLerpNodePathInterval::get_class_type 0 1 126 0
62
static TypeHandle CLerpNodePathInterval::get_class_type(void);

280 22 ~CLerpNodePathInterval 4 326 45 CLerpNodePathInterval::~CLerpNodePathInterval 0 0 0
52
CLerpNodePathInterval::~CLerpNodePathInterval(void);

281 13 CMetaInterval 4 327 28 CMetaInterval::CMetaInterval 0 1 127 226
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
63
CMetaInterval::CMetaInterval(basic_string< char > const &name);

282 13 set_precision 4 327 28 CMetaInterval::set_precision 0 1 128 1201
// Filename: cMetaInterval.I
// Created by:  drose (27Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::set_precision
//       Access: Published
//  Description: Indicates the precision with which time measurements
//               are compared.  For numerical accuracy, all
//               floating-point time values are converted to integer
//               values internally by scaling by the precision factor.
//               The larger the number given here, the smaller the
//               delta of time that can be differentiated; the
//               limit is the maximum integer that can be represented
//               in the system.
////////////////////////////////////////////////////////////////////
59
inline void CMetaInterval::set_precision(double precision);

283 13 get_precision 4 327 28 CMetaInterval::get_precision 0 1 129 331
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_precision
//       Access: Published
//  Description: Returns the precision with which time measurements
//               are compared.  See set_precision().
////////////////////////////////////////////////////////////////////
55
inline double CMetaInterval::get_precision(void) const;

284 15 clear_intervals 4 327 30 CMetaInterval::clear_intervals 0 1 130 314
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::clear_intervals
//       Access: Published
//  Description: Resets the list of intervals and prepares for
//               receiving a new list.
////////////////////////////////////////////////////////////////////
42
void CMetaInterval::clear_intervals(void);

285 10 push_level 4 327 25 CMetaInterval::push_level 0 1 131 647
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::push_level
//       Access: Published
//  Description: Marks the beginning of a nested level of child
//               intervals.  Within the nested level, a RelativeStart
//               time of RS_level_begin refers to the start of the
//               level, and the first interval added within the level
//               is always relative to the start of the level.
//
//               The return value is the index of the def entry
//               created by this push.
////////////////////////////////////////////////////////////////////
118
int CMetaInterval::push_level(basic_string< char > const &name, double rel_time, CMetaInterval::RelativeStart rel_to);

286 14 add_c_interval 4 327 29 CMetaInterval::add_c_interval 0 3 132 133 134 512
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::add_c_interval
//       Access: Published
//  Description: Adds a new CInterval to the list.  The interval will
//               be played when the indicated time (relative to the
//               given point) has been reached.
//
//               The return value is the index of the def entry
//               representing the new interval.
////////////////////////////////////////////////////////////////////
137
int CMetaInterval::add_c_interval(CInterval *c_interval, double rel_time = (0), CMetaInterval::RelativeStart rel_to = (RS_previous_end));

287 13 add_ext_index 4 327 28 CMetaInterval::add_ext_index 0 1 135 1156
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::add_ext_index
//       Access: Published
//  Description: Adds a new external interval to the list.  This
//               represents some object in the external scripting
//               language that has properties similar to a CInterval
//               (for instance, a Python Interval object).
//
//               The CMetaInterval object cannot play this external
//               interval directly, but it records a placeholder for
//               it and will ask the scripting language to play it
//               when it is time, via is_event_ready() and related
//               methods.
//
//               The ext_index number itself is simply a handle that
//               the scripting language makes up and associates with
//               its interval object somehow.  The CMetaInterval
//               object does not attempt to interpret this value.
//
//               The return value is the index of the def entry
//               representing the new interval.
////////////////////////////////////////////////////////////////////
170
int CMetaInterval::add_ext_index(int ext_index, basic_string< char > const &name, double duration, bool open_ended, double rel_time, CMetaInterval::RelativeStart rel_to);

288 9 pop_level 4 327 24 CMetaInterval::pop_level 0 2 136 137 645
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::pop_level
//       Access: Published
//  Description: Finishes a level marked by a previous call to
//               push_level(), and returns to the previous level.
//
//               If the duration is not negative, it represents a
//               phony duration to assign to the level, for the
//               purposes of sequencing later intervals.  Otherwise,
//               the level's duration is computed based on the
//               intervals within the level.
////////////////////////////////////////////////////////////////////
53
int CMetaInterval::pop_level(double duration = (-1));

289 23 set_interval_start_time 4 327 38 CMetaInterval::set_interval_start_time 0 2 138 139 824
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::set_interval_start_time
//       Access: Published
//  Description: Adjusts the start time of the child interval with the
//               given name, if found.  This may be either a C++
//               interval added via add_c_interval(), or an external
//               interval added via add_ext_index(); the name must
//               match exactly.
//
//               If the interval is found, its start time is adjusted,
//               and all subsequent intervals are adjusting
//               accordingly, and true is returned.  If a matching
//               interval is not found, nothing is changed and false
//               is returned.
////////////////////////////////////////////////////////////////////
151
bool CMetaInterval::set_interval_start_time(basic_string< char > const &name, double rel_time, CMetaInterval::RelativeStart rel_to = (RS_level_begin));

290 23 get_interval_start_time 4 327 38 CMetaInterval::get_interval_start_time 0 1 140 451
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_interval_start_time
//       Access: Published
//  Description: Returns the actual start time, relative to the
//               beginning of the interval, of the child interval with
//               the given name, if found, or -1 if the interval is
//               not found.
////////////////////////////////////////////////////////////////////
86
double CMetaInterval::get_interval_start_time(basic_string< char > const &name) const;

291 21 get_interval_end_time 4 327 36 CMetaInterval::get_interval_end_time 0 1 141 447
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_interval_end_time
//       Access: Published
//  Description: Returns the actual end time, relative to the
//               beginning of the interval, of the child interval with
//               the given name, if found, or -1 if the interval is
//               not found.
////////////////////////////////////////////////////////////////////
84
double CMetaInterval::get_interval_end_time(basic_string< char > const &name) const;

292 12 get_num_defs 4 327 27 CMetaInterval::get_num_defs 0 1 142 359
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_num_defs
//       Access: Published
//  Description: Returns the number of interval and push/pop
//               definitions that have been added to the meta
//               interval.
////////////////////////////////////////////////////////////////////
51
inline int CMetaInterval::get_num_defs(void) const;

293 12 get_def_type 4 327 27 CMetaInterval::get_def_type 0 1 143 312
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_def_type
//       Access: Published
//  Description: Returns the type of the nth interval definition that
//               has been added.
////////////////////////////////////////////////////////////////////
71
inline CMetaInterval::DefType CMetaInterval::get_def_type(int n) const;

294 14 get_c_interval 4 327 29 CMetaInterval::get_c_interval 0 1 144 409
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_c_interval
//       Access: Published
//  Description: Return the CInterval pointer associated with the nth
//               interval definition.  It is only valid to call this
//               if get_def_type(n) returns DT_c_interval.
////////////////////////////////////////////////////////////////////
61
inline CInterval *CMetaInterval::get_c_interval(int n) const;

295 13 get_ext_index 4 327 28 CMetaInterval::get_ext_index 0 1 145 420
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_ext_index
//       Access: Published
//  Description: Return the external interval index number associated
//               with the nth interval definition.  It is only valid
//               to call this if get_def_type(n) returns DT_ext_index.
////////////////////////////////////////////////////////////////////
53
inline int CMetaInterval::get_ext_index(int n) const;

296 14 is_event_ready 4 327 29 CMetaInterval::is_event_ready 0 1 146 544
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::is_event_ready
//       Access: Published
//  Description: Returns true if a recent call to priv_initialize(),
//               priv_step(), or priv_finalize() has left some external
//               intervals ready to play.  If this returns true, call
//               get_event_index(), get_event_t(), and pop_event() to
//               retrieve the relevant information.
////////////////////////////////////////////////////////////////////
48
inline bool CMetaInterval::is_event_ready(void);

297 15 get_event_index 4 327 30 CMetaInterval::get_event_index 0 1 147 444
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_event_index
//       Access: Published
//  Description: If a previous call to is_event_ready() returned
//               true, this returns the index number (added via
//               add_event_index()) of the external interval that needs
//               to be played.
////////////////////////////////////////////////////////////////////
54
inline int CMetaInterval::get_event_index(void) const;

298 11 get_event_t 4 327 26 CMetaInterval::get_event_t 0 1 148 380
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_event_t
//       Access: Published
//  Description: If a previous call to is_event_ready() returned
//               true, this returns the t value that should be fed to
//               the given interval.
////////////////////////////////////////////////////////////////////
53
inline double CMetaInterval::get_event_t(void) const;

299 14 get_event_type 4 327 29 CMetaInterval::get_event_type 0 1 149 410
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_event_type
//       Access: Published
//  Description: If a previous call to is_event_ready() returned
//               true, this returns the type of the event (initialize,
//               step, finalize, etc.) for the given interval.
////////////////////////////////////////////////////////////////////
70
inline CInterval::EventType CMetaInterval::get_event_type(void) const;

300 9 pop_event 4 327 24 CMetaInterval::pop_event 0 1 150 591
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::pop_event
//       Access: Published
//  Description: Acknowledges that the external interval on the top of
//               the queue has been extracted, and is about to be
//               serviced by the scripting language.  This prepares
//               the interval so the next call to is_event_ready()
//               will return information about the next external
//               interval on the queue, if any.
////////////////////////////////////////////////////////////////////
36
void CMetaInterval::pop_event(void);

301 8 timeline 4 327 23 CMetaInterval::timeline 0 1 151 302
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::timeline
//       Access: Published
//  Description: Outputs a list of all events in the order in which
//               they occur.
////////////////////////////////////////////////////////////////////
49
void CMetaInterval::timeline(ostream &out) const;

302 14 get_class_type 4 327 29 CMetaInterval::get_class_type 0 1 152 0
54
static TypeHandle CMetaInterval::get_class_type(void);

303 12 HideInterval 4 330 26 HideInterval::HideInterval 0 2 153 154 225
////////////////////////////////////////////////////////////////////
//     Function: HideInterval::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
98
HideInterval::HideInterval(NodePath const &node, basic_string< char > const &name = ((string())));

304 14 get_class_type 4 330 28 HideInterval::get_class_type 0 1 155 0
53
static TypeHandle HideInterval::get_class_type(void);

305 13 ~HideInterval 4 330 27 HideInterval::~HideInterval 0 0 0
34
HideInterval::~HideInterval(void);

306 12 ShowInterval 4 331 26 ShowInterval::ShowInterval 0 2 156 157 225
////////////////////////////////////////////////////////////////////
//     Function: ShowInterval::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
98
ShowInterval::ShowInterval(NodePath const &node, basic_string< char > const &name = ((string())));

307 14 get_class_type 4 331 28 ShowInterval::get_class_type 0 1 158 0
53
static TypeHandle ShowInterval::get_class_type(void);

308 13 ~ShowInterval 4 331 27 ShowInterval::~ShowInterval 0 0 0
34
ShowInterval::~ShowInterval(void);

309 12 WaitInterval 4 332 26 WaitInterval::WaitInterval 0 1 159 827
// Filename: waitInterval.I
// Created by:  drose (12Sep02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: WaitInterval::Constructor
//       Access: Published
//  Description: All Wait intervals have the same name.  No one really
//               cares if their names are unique, after all.
////////////////////////////////////////////////////////////////////
51
inline WaitInterval::WaitInterval(double duration);

310 14 get_class_type 4 332 28 WaitInterval::get_class_type 0 1 160 0
53
static TypeHandle WaitInterval::get_class_type(void);

311 13 ~WaitInterval 4 332 27 WaitInterval::~WaitInterval 0 0 0
34
WaitInterval::~WaitInterval(void);

160
1 14 Dtool_SpsCfV5F 6 3 335 0 14 Dtool_SpsCfV5F 732 // Filename: cInterval.I
// Created by:  drose (27Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_name
//       Access: Published
//  Description: Returns the interval's name.
//////////////////////////////////////////////////////////////////// 1 4 this 3 333  
2 14 Dtool_SpsC8svE 6 4 336 0 14 Dtool_SpsC8svE 271 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_duration
//       Access: Published
//  Description: Returns the duration of the interval in seconds.
//////////////////////////////////////////////////////////////////// 1 4 this 3 333  
3 14 Dtool_SpsCB6uv 6 5 317 0 14 Dtool_SpsCB6uv 685 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_open_ended
//       Access: Published
//  Description: Returns the state of the "open_ended" flag.  This is
//               primarily intended for instantaneous intervals like
//               FunctionIntervals; it indicates true if the interval
//               has some lasting effect that should be applied even
//               if the interval doesn't get started until after its
//               finish time, or false if the interval is a transitive
//               thing that doesn't need to be called late.
//////////////////////////////////////////////////////////////////// 1 4 this 3 333  
4 14 Dtool_SpsCvfjT 6 8 315 0 14 Dtool_SpsCvfjT 385 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_state
//       Access: Published
//  Description: Indicates the state the interval believes it is in:
//               whether it has been started, is currently in the
//               middle, or has been finalized.
//////////////////////////////////////////////////////////////////// 1 4 this 3 333  
5 14 Dtool_SpsCs6CA 6 9 317 0 14 Dtool_SpsCs6CA 364 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::is_stopped
//       Access: Published
//  Description: Returns true if the interval is in either its initial
//               or final states (but not in a running or paused
//               state).
//////////////////////////////////////////////////////////////////// 1 4 this 3 333  
6 14 Dtool_SpsCso5p 4 10 338 0 14 Dtool_SpsCso5p 426 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_done_event
//       Access: Published
//  Description: Sets the event that is generated whenever the
//               interval reaches its final state, whether it is
//               explicitly finished or whether it gets there on its
//               own.
//////////////////////////////////////////////////////////////////// 2 4 this 3 337  5 event 1 335  
7 14 Dtool_SpsCU1_s 6 11 335 0 14 Dtool_SpsCU1_s 429 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_done_event
//       Access: Published
//  Description: Returns the event that is generated whenever the
//               interval reaches its final state, whether it is
//               explicitly finished or whether it gets there on its
//               own.
//////////////////////////////////////////////////////////////////// 1 4 this 3 333  
8 14 Dtool_SpsCnHap 4 12 338 0 14 Dtool_SpsCnHap 450 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_t
//       Access: Published
//  Description: Explicitly sets the time within the interval.
//               Normally, you would use start() .. finish() to let
//               the time play normally, but this may be used to set
//               the time to some particular value.
//////////////////////////////////////////////////////////////////// 2 4 this 3 337  1 t 1 336  
9 14 Dtool_SpsCEMrp 6 13 336 0 14 Dtool_SpsCEMrp 373 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_t
//       Access: Published
//  Description: Returns the current time of the interval: the last
//               value of t passed to priv_initialize(), priv_step(), or
//               priv_finalize().
//////////////////////////////////////////////////////////////////// 1 4 this 3 333  
10 14 Dtool_SpsCK6Bt 4 14 338 0 14 Dtool_SpsCK6Bt 624 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_auto_pause
//       Access: Published
//  Description: Changes the state of the 'auto_pause' flag.  If
//               this is true, the interval may be arbitrarily
//               interrupted when the system needs to reset due to
//               some external event by calling
//               CIntervalManager::interrupt().  If this
//               is false (the default), the interval must always be
//               explicitly finished or paused.
//////////////////////////////////////////////////////////////////// 2 4 this 3 337  10 auto_pause 1 317  
11 14 Dtool_SpsCLOK8 6 15 317 0 14 Dtool_SpsCLOK8 308 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_auto_pause
//       Access: Published
//  Description: Returns the state of the 'auto_pause' flag.  See
//               set_auto_pause().
//////////////////////////////////////////////////////////////////// 1 4 this 3 333  
12 14 Dtool_SpsCwEgz 4 16 338 0 14 Dtool_SpsCwEgz 623 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_auto_finish
//       Access: Published
//  Description: Changes the state of the 'auto_finish' flag.  If
//               this is true, the interval may be arbitrarily
//               finished when the system needs to reset due to
//               some external event by calling
//               CIntervalManager::interrupt().  If this
//               is false (the default), the interval must always be
//               explicitly finished or paused.
//////////////////////////////////////////////////////////////////// 2 4 this 3 337  11 auto_finish 1 317  
13 14 Dtool_SpsCK3xj 6 17 317 0 14 Dtool_SpsCK3xj 311 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_auto_finish
//       Access: Published
//  Description: Returns the state of the 'auto_finish' flag.  See
//               set_auto_finish().
//////////////////////////////////////////////////////////////////// 1 4 this 3 333  
14 14 Dtool_SpsCU4Wd 4 18 338 0 14 Dtool_SpsCU4Wd 533 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_wants_t_callback
//       Access: Published
//  Description: Changes the state of the 'wants_t_callback' flag.  If
//               this is true, the interval will be returned by
//               CIntervalManager::get_event() each time the
//               interval's time value has been changed, regardless of
//               whether it has any external events.
//////////////////////////////////////////////////////////////////// 2 4 this 3 337  16 wants_t_callback 1 317  
15 14 Dtool_SpsCzuIb 6 19 317 0 14 Dtool_SpsCzuIb 325 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_wants_t_callback
//       Access: Published
//  Description: Returns the state of the 'wants_t_callback' flag.
//               See set_wants_t_callback().
//////////////////////////////////////////////////////////////////// 1 4 this 3 333  
16 14 Dtool_SpsCVrzY 4 20 338 0 14 Dtool_SpsCVrzY 523 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_manager
//       Access: Published
//  Description: Indicates the CIntervalManager object which will be
//               responsible for playing this interval.  This defaults
//               to the global CIntervalManager; you should need to
//               change this only if you have special requirements for
//               playing this interval.
//////////////////////////////////////////////////////////////////// 2 4 this 3 337  7 manager 1 339  
17 14 Dtool_SpsCzijv 6 21 339 0 14 Dtool_SpsCzijv 604 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_manager
//       Access: Published
//  Description: Returns the CIntervalManager object which will be
//               responsible for playing this interval.  Note that
//               this can only return a C++ object; if the particular
//               CIntervalManager object has been extended in the
//               scripting language, this will return the encapsulated
//               C++ object, not the full extended object.
//////////////////////////////////////////////////////////////////// 1 4 this 3 333  
18 14 Dtool_SpsCOA1D 4 22 338 0 14 Dtool_SpsCOA1D 478 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::start
//       Access: Published
//  Description: Starts the interval playing by registering it with
//               the current CIntervalManager.  The interval will
//               play to the end and stop.
//
//               If end_t is less than zero, it indicates the end of
//               the interval.
//////////////////////////////////////////////////////////////////// 4 4 this 3 337  7 start_t 1 336  5 end_t 1 336  9 play_rate 1 336  
19 14 Dtool_SpsCsz84 4 22 338 0 14 Dtool_SpsCsz84 478 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::start
//       Access: Published
//  Description: Starts the interval playing by registering it with
//               the current CIntervalManager.  The interval will
//               play to the end and stop.
//
//               If end_t is less than zero, it indicates the end of
//               the interval.
//////////////////////////////////////////////////////////////////// 3 4 this 3 337  7 start_t 1 336  5 end_t 1 336  
20 14 Dtool_SpsCV_pK 4 22 338 0 14 Dtool_SpsCV_pK 478 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::start
//       Access: Published
//  Description: Starts the interval playing by registering it with
//               the current CIntervalManager.  The interval will
//               play to the end and stop.
//
//               If end_t is less than zero, it indicates the end of
//               the interval.
//////////////////////////////////////////////////////////////////// 2 4 this 3 337  7 start_t 1 336  
21 14 Dtool_SpsCI9Ch 4 22 338 0 14 Dtool_SpsCI9Ch 478 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::start
//       Access: Published
//  Description: Starts the interval playing by registering it with
//               the current CIntervalManager.  The interval will
//               play to the end and stop.
//
//               If end_t is less than zero, it indicates the end of
//               the interval.
//////////////////////////////////////////////////////////////////// 1 4 this 3 337  
22 14 Dtool_SpsClvuV 4 23 338 0 14 Dtool_SpsClvuV 587 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::loop
//       Access: Published
//  Description: Starts the interval playing by registering it with
//               the current CIntervalManager.  The interval will
//               play until it is interrupted with finish() or
//               pause(), looping back to start_t when it reaches
//               end_t.
//
//               If end_t is less than zero, it indicates the end of
//               the interval.
//////////////////////////////////////////////////////////////////// 4 4 this 3 337  7 start_t 1 336  5 end_t 1 336  9 play_rate 1 336  
23 14 Dtool_SpsCN0b7 4 23 338 0 14 Dtool_SpsCN0b7 587 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::loop
//       Access: Published
//  Description: Starts the interval playing by registering it with
//               the current CIntervalManager.  The interval will
//               play until it is interrupted with finish() or
//               pause(), looping back to start_t when it reaches
//               end_t.
//
//               If end_t is less than zero, it indicates the end of
//               the interval.
//////////////////////////////////////////////////////////////////// 3 4 this 3 337  7 start_t 1 336  5 end_t 1 336  
24 14 Dtool_SpsCDdAk 4 23 338 0 14 Dtool_SpsCDdAk 587 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::loop
//       Access: Published
//  Description: Starts the interval playing by registering it with
//               the current CIntervalManager.  The interval will
//               play until it is interrupted with finish() or
//               pause(), looping back to start_t when it reaches
//               end_t.
//
//               If end_t is less than zero, it indicates the end of
//               the interval.
//////////////////////////////////////////////////////////////////// 2 4 this 3 337  7 start_t 1 336  
25 14 Dtool_SpsCdHuO 4 23 338 0 14 Dtool_SpsCdHuO 587 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::loop
//       Access: Published
//  Description: Starts the interval playing by registering it with
//               the current CIntervalManager.  The interval will
//               play until it is interrupted with finish() or
//               pause(), looping back to start_t when it reaches
//               end_t.
//
//               If end_t is less than zero, it indicates the end of
//               the interval.
//////////////////////////////////////////////////////////////////// 1 4 this 3 337  
26 14 Dtool_SpsCYZXB 6 24 336 0 14 Dtool_SpsCYZXB 379 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::pause
//       Access: Published
//  Description: Stops the interval from playing but leaves it in its
//               current state.  It may later be resumed from this
//               point by calling resume().
//////////////////////////////////////////////////////////////////// 1 4 this 3 337  
27 14 Dtool_SpsCOoeF 4 25 338 0 14 Dtool_SpsCOoeF 312 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::resume
//       Access: Published
//  Description: Restarts the interval from its current point after a
//               previous call to pause().
//////////////////////////////////////////////////////////////////// 1 4 this 3 337  
28 14 Dtool_SpsCC2L6 4 25 338 0 14 Dtool_SpsCC2L6 314 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::resume
//       Access: Published
//  Description: Restarts the interval from the indicated point after a
//               previous call to pause().
//////////////////////////////////////////////////////////////////// 2 4 this 3 337  7 start_t 1 336  
29 14 Dtool_SpsCYMh8 4 26 338 0 14 Dtool_SpsCYMh8 440 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::resume_until
//       Access: Published
//  Description: Restarts the interval from the current point after a
//               previous call to pause() (or a previous
//               play-to-point-and-stop), to play until the indicated
//               point and then stop.
//////////////////////////////////////////////////////////////////// 2 4 this 3 337  5 end_t 1 336  
30 14 Dtool_SpsCIWoe 4 27 338 0 14 Dtool_SpsCIWoe 297 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::finish
//       Access: Published
//  Description: Stops the interval from playing and sets it to its
//               final state.
//////////////////////////////////////////////////////////////////// 1 4 this 3 337  
31 14 Dtool_SpsC9awK 4 28 338 0 14 Dtool_SpsC9awK 551 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::clear_to_initial
//       Access: Published
//  Description: Pauses the interval, if it is playing, and resets its
//               state to its initial state, abandoning any state
//               changes already in progress in the middle of the
//               interval.  Calling this is like pausing the interval
//               and discarding it, creating a new one in its place.
//////////////////////////////////////////////////////////////////// 1 4 this 3 337  
32 14 Dtool_SpsCLlcY 6 29 317 0 14 Dtool_SpsCLlcY 305 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::is_playing
//       Access: Published
//  Description: Returns true if the interval is currently playing,
//               false otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 333  
33 14 Dtool_SpsCh9_Q 6 30 336 0 14 Dtool_SpsCh9_Q 326 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::get_play_rate
//       Access: Published
//  Description: Returns the play rate as set by the last call to
//               start(), loop(), or set_play_rate().
//////////////////////////////////////////////////////////////////// 1 4 this 3 333  
34 14 Dtool_SpsChAaa 4 31 338 0 14 Dtool_SpsChAaa 529 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::set_play_rate
//       Access: Published
//  Description: Changes the play rate of the interval.  If the
//               interval is already started, this changes its speed
//               on-the-fly.  Note that since play_rate is a parameter
//               to start() and loop(), the next call to start() or
//               loop() will reset this parameter.
//////////////////////////////////////////////////////////////////// 2 4 this 3 337  9 play_rate 1 336  
35 14 Dtool_SpsCsrd8 4 32 338 0 14 Dtool_SpsCsrd8 402 // These functions control the actual playback of the interval.
// Don't call them directly; they're intended to be called from a
// supervising object, e.g. the Python start() .. finish()
// interface.
// These cannot be declared private because they must be accessible
// to Python, but the method names are prefixed with priv_ to remind
// you that you probably don't want to be using them directly. 3 4 this 3 337  1 t 1 336  5 event 1 314  
36 14 Dtool_SpsCADw2 4 33 338 0 14 Dtool_SpsCADw2 485 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_initialize
//       Access: Published, Virtual
//  Description: This replaces the first call to priv_step(), and indicates
//               that the interval has just begun.  This may be
//               overridden by derived classes that need to do some
//               explicit initialization on the first call.
//////////////////////////////////////////////////////////////////// 2 4 this 3 337  1 t 1 336  
37 14 Dtool_SpsC_B_n 4 34 338 0 14 Dtool_SpsC_B_n 486 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_instant
//       Access: Published, Virtual
//  Description: This is called in lieu of priv_initialize() .. priv_step()
//               .. priv_finalize(), when everything is to happen within
//               one frame.  The interval should initialize itself,
//               then leave itself in the final state.
//////////////////////////////////////////////////////////////////// 1 4 this 3 337  
38 14 Dtool_SpsCU3CU 4 35 338 0 14 Dtool_SpsCU3CU 409 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_step
//       Access: Published, Virtual
//  Description: Advances the time on the interval.  The time may
//               either increase (the normal case) or decrease
//               (e.g. if the interval is being played by a slider).
//////////////////////////////////////////////////////////////////// 2 4 this 3 337  1 t 1 336  
39 14 Dtool_SpsCcdRd 4 36 338 0 14 Dtool_SpsCcdRd 439 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_finalize
//       Access: Published, Virtual
//  Description: This is called to stop an interval, forcing it to
//               whatever state it would be after it played all the
//               way through.  It's generally invoked by
//               set_final_t().
//////////////////////////////////////////////////////////////////// 1 4 this 3 337  
40 14 Dtool_SpsCzQVo 4 37 338 0 14 Dtool_SpsCzQVo 485 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::reverse_initialize
//       Access: Published, Virtual
//  Description: Similar to priv_initialize(), but this is called when the
//               interval is being played backwards; it indicates that
//               the interval should start at the finishing state and
//               undo any intervening intervals.
//////////////////////////////////////////////////////////////////// 2 4 this 3 337  1 t 1 336  
41 14 Dtool_SpsCyAlT 4 38 338 0 14 Dtool_SpsCyAlT 524 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::reverse_instant
//       Access: Published, Virtual
//  Description: This is called in lieu of priv_reverse_initialize()
//               .. priv_step() .. priv_reverse_finalize(), when everything is
//               to happen within one frame.  The interval should
//               initialize itself, then leave itself in the initial
//               state.
//////////////////////////////////////////////////////////////////// 1 4 this 3 337  
42 14 Dtool_SpsCtoBu 4 39 338 0 14 Dtool_SpsCtoBu 393 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::reverse_finalize
//       Access: Published, Virtual
//  Description: Called generally following a priv_reverse_initialize(),
//               this indicates the interval should set itself to the
//               initial state.
//////////////////////////////////////////////////////////////////// 1 4 this 3 337  
43 14 Dtool_SpsCpKBe 4 40 338 0 14 Dtool_SpsCpKBe 812 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::priv_interrupt
//       Access: Published, Virtual
//  Description: This is called while the interval is playing to
//               indicate that it is about to be interrupted; that is,
//               priv_step() will not be called for a length of time.  But
//               the interval should remain in its current state in
//               anticipation of being eventually restarted when the
//               calls to priv_step() eventually resume.
//
//               The purpose of this function is to allow self-running
//               intervals like sound intervals to stop the actual
//               sound playback during the pause.
//////////////////////////////////////////////////////////////////// 1 4 this 3 337  
44 14 Dtool_SpsC6w_D 4 41 338 0 14 Dtool_SpsC6w_D 226 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::output
//       Access: Published, Virtual
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 333  3 out 1 340  
45 14 Dtool_SpsCLeD7 4 42 338 0 14 Dtool_SpsCLeD7 225 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::write
//       Access: Published, Virtual
//  Description: 
//////////////////////////////////////////////////////////////////// 3 4 this 3 333  3 out 1 340  12 indent_level 1 342  
46 14 Dtool_SpsCzgQa 4 43 338 0 14 Dtool_SpsCzgQa 831 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::setup_play
//       Access: Published
//  Description: Called to prepare the interval for automatic timed
//               playback, e.g. via a Python task.  The interval will
//               be played from start_t to end_t, at a time factor
//               specified by play_rate.  start_t must always be less
//               than end_t (except for the exception for end_t == -1,
//               below), but if play_rate is negative the interval
//               will be played backwards.
//
//               Specify end_t of -1 to play the entire interval from
//               start_t.
//
//               Call step_play() repeatedly to execute the interval.
//////////////////////////////////////////////////////////////////// 5 4 this 3 337  10 start_time 1 336  8 end_time 1 336  9 play_rate 1 336  7 do_loop 1 317  
47 14 Dtool_SpsCUryc 4 44 338 0 14 Dtool_SpsCUryc 366 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::setup_resume
//       Access: Published
//  Description: Called to prepare the interval for restarting at the
//               current point within the interval after an
//               interruption.
//////////////////////////////////////////////////////////////////// 1 4 this 3 337  
48 14 Dtool_SpsCscch 4 45 338 0 14 Dtool_SpsCscch 470 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::setup_resume_until
//       Access: Published
//  Description: Called to prepare the interval for restarting from
//               the current point after a previous call to pause()
//               (or a previous play-to-point-and-stop), to play until
//               the indicated point and then stop.
//////////////////////////////////////////////////////////////////// 2 4 this 3 337  5 end_t 1 336  
49 14 Dtool_SpsCNGqy 6 46 317 0 14 Dtool_SpsCNGqy 453 ////////////////////////////////////////////////////////////////////
//     Function: CInterval::step_play
//       Access: Published
//  Description: Should be called once per frame to execute the
//               automatic timed playback begun with setup_play().
//
//               Returns true if the interval should continue, false
//               if it is done and should stop.
//////////////////////////////////////////////////////////////////// 1 4 this 3 337  
50 14 Dtool_SpsCStxv 7 47 344 0 14 Dtool_SpsCStxv 0 0 
51 14 Dtool_SpsC3rB9 7 53 344 0 14 Dtool_SpsC3rB9 0 0 
52 14 Dtool_SpsC6b9E 6 50 317 0 14 Dtool_SpsC6b9E 0 1 4 this 3 345  
53 14 Dtool_SpsCnsBv 4 51 338 0 14 Dtool_SpsCnsBv 0 2 4 this 3 347  5 value 1 317  
54 14 Dtool_SpsCjm3B 7 56 354 212 14 Dtool_SpsCjm3B 682 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainHprInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the orientation of one node to the orientation of
//               another, possibly with an added rotation.
//
//               If wrt is true, the node's orientation will be
//               transformed into the target node's parent's  space
//               before being copied.  If wrt is false, the target
//               node's local orientation will be copied unaltered.
//////////////////////////////////////////////////////////////////// 6 4 name 1 335  8 duration 1 336  4 node 1 348  6 target 1 348  3 wrt 1 317  9 hprOffset 1 351  
55 14 Dtool_SpsCJRAe 7 56 354 212 14 Dtool_SpsCJRAe 682 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainHprInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the orientation of one node to the orientation of
//               another, possibly with an added rotation.
//
//               If wrt is true, the node's orientation will be
//               transformed into the target node's parent's  space
//               before being copied.  If wrt is false, the target
//               node's local orientation will be copied unaltered.
//////////////////////////////////////////////////////////////////// 5 4 name 1 335  8 duration 1 336  4 node 1 348  6 target 1 348  3 wrt 1 317  
56 14 Dtool_SpsCG_dN 6 57 348 0 14 Dtool_SpsCG_dN 754 // Filename: cConstrainHprInterval.I
// Created by:  pratt (10Mar08)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CConstrainHprInterval::get_node
//       Access: Published
//  Description: Returns the "source" node.
//////////////////////////////////////////////////////////////////// 1 4 this 3 355  
57 14 Dtool_SpsCptoY 6 58 348 0 14 Dtool_SpsCptoY 259 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainHprInterval::get_target
//       Access: Published
//  Description: Returns the "target" node.
//////////////////////////////////////////////////////////////////// 1 4 this 3 355  
58 14 Dtool_SpsCka3O 7 59 344 0 14 Dtool_SpsCka3O 0 0 
59 14 Dtool_SpsCpdjK 7 62 357 217 14 Dtool_SpsCpdjK 720 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosHprInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the position and orientation of one node to the
//               position and orientation of another.
//
//               If wrt is true, the node's position and orientation
//               will be transformed into the target node's parent's
//               space before being copied.  If wrt is false, the
//               target node's local position and orientation will be
//               copied unaltered.
//////////////////////////////////////////////////////////////////// 7 4 name 1 335  8 duration 1 336  4 node 1 348  6 target 1 348  3 wrt 1 317  9 posOffset 1 351  9 hprOffset 1 351  
60 14 Dtool_SpsCMtsm 7 62 357 217 14 Dtool_SpsCMtsm 720 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosHprInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the position and orientation of one node to the
//               position and orientation of another.
//
//               If wrt is true, the node's position and orientation
//               will be transformed into the target node's parent's
//               space before being copied.  If wrt is false, the
//               target node's local position and orientation will be
//               copied unaltered.
//////////////////////////////////////////////////////////////////// 6 4 name 1 335  8 duration 1 336  4 node 1 348  6 target 1 348  3 wrt 1 317  9 posOffset 1 351  
61 14 Dtool_SpsCC34s 7 62 357 217 14 Dtool_SpsCC34s 720 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosHprInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the position and orientation of one node to the
//               position and orientation of another.
//
//               If wrt is true, the node's position and orientation
//               will be transformed into the target node's parent's
//               space before being copied.  If wrt is false, the
//               target node's local position and orientation will be
//               copied unaltered.
//////////////////////////////////////////////////////////////////// 5 4 name 1 335  8 duration 1 336  4 node 1 348  6 target 1 348  3 wrt 1 317  
62 14 Dtool_SpsCV1_L 6 63 348 0 14 Dtool_SpsCV1_L 760 // Filename: cConstrainPosHprInterval.I
// Created by:  pratt (10Mar08)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosHprInterval::get_node
//       Access: Published
//  Description: Returns the "source" node.
//////////////////////////////////////////////////////////////////// 1 4 this 3 358  
63 14 Dtool_SpsCJY4x 6 64 348 0 14 Dtool_SpsCJY4x 262 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosHprInterval::get_target
//       Access: Published
//  Description: Returns the "target" node.
//////////////////////////////////////////////////////////////////// 1 4 this 3 358  
64 14 Dtool_SpsCMQBo 7 65 344 0 14 Dtool_SpsCMQBo 0 0 
65 14 Dtool_SpsC3PgQ 7 68 360 222 14 Dtool_SpsC3PgQ 620 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the position of one node to the position of another.
//
//               If wrt is true, the node's position will be
//               transformed into the target node's parent's  space
//               before being copied.  If wrt is false, the target
//               node's local position will be copied unaltered.
//////////////////////////////////////////////////////////////////// 6 4 name 1 335  8 duration 1 336  4 node 1 348  6 target 1 348  3 wrt 1 317  9 posOffset 1 351  
66 14 Dtool_SpsCxoqs 7 68 360 222 14 Dtool_SpsCxoqs 620 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the position of one node to the position of another.
//
//               If wrt is true, the node's position will be
//               transformed into the target node's parent's  space
//               before being copied.  If wrt is false, the target
//               node's local position will be copied unaltered.
//////////////////////////////////////////////////////////////////// 5 4 name 1 335  8 duration 1 336  4 node 1 348  6 target 1 348  3 wrt 1 317  
67 14 Dtool_SpsCnovZ 6 69 348 0 14 Dtool_SpsCnovZ 754 // Filename: cConstrainPosInterval.I
// Created by:  pratt (29Sep06)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosInterval::get_node
//       Access: Published
//  Description: Returns the "source" node.
//////////////////////////////////////////////////////////////////// 1 4 this 3 361  
68 14 Dtool_SpsCIT5k 6 70 348 0 14 Dtool_SpsCIT5k 259 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainPosInterval::get_target
//       Access: Published
//  Description: Returns the "target" node.
//////////////////////////////////////////////////////////////////// 1 4 this 3 361  
69 14 Dtool_SpsCHgJb 7 71 344 0 14 Dtool_SpsCHgJb 0 0 
70 14 Dtool_SpsC_uho 7 74 363 227 14 Dtool_SpsC_uho 700 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainTransformInterval::Constructor
//       Access: Published
//  Description: Constructs a constraint interval that will constrain
//               the transform of one node to the transform of another.
//               To clarify, the transform of node will be copied to target.
//
//               If wrt is true, the node's transform will be
//               transformed into the target node's parent's  space
//               before being copied.  If wrt is false, the node's
//               local transform will be copied unaltered.
//////////////////////////////////////////////////////////////////// 5 4 name 1 335  8 duration 1 336  4 node 1 348  6 target 1 348  3 wrt 1 317  
71 14 Dtool_SpsCFPOL 6 75 348 0 14 Dtool_SpsCFPOL 766 // Filename: cConstrainTransformInterval.I
// Created by:  pratt (29Sep06)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CConstrainTransformInterval::get_node
//       Access: Published
//  Description: Returns the "source" node.
//////////////////////////////////////////////////////////////////// 1 4 this 3 364  
72 14 Dtool_SpsCu58V 6 76 348 0 14 Dtool_SpsCu58V 265 ////////////////////////////////////////////////////////////////////
//     Function: CConstrainTransformInterval::get_target
//       Access: Published
//  Description: Returns the "target" node.
//////////////////////////////////////////////////////////////////// 1 4 this 3 364  
73 14 Dtool_SpsC2uzl 7 77 344 0 14 Dtool_SpsC2uzl 0 0 
74 14 Dtool_SpsC7SV3 7 80 339 229 14 Dtool_SpsC7SV3 229 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 0 
75 14 Dtool_SpsCH947 4 82 338 0 14 Dtool_SpsCH947 1195 // Filename: cIntervalManager.I
// Created by:  drose (10Sep02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::set_event_queue
//       Access: Published
//  Description: Specifies a custom event queue to be used for
//               throwing done events from intervals as they finish.
//               If this is not specified, the global event queue is
//               used.
//
//               The caller maintains ownership of the EventQueue
//               object; it is the caller's responsibility to ensure
//               that the supplied EventQueue does not destruct during
//               the lifetime of the CIntervalManager.
//////////////////////////////////////////////////////////////////// 2 4 this 3 339  11 event_queue 1 366  
76 14 Dtool_SpsC4ah3 6 83 366 0 14 Dtool_SpsC4ah3 347 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_event_queue
//       Access: Published
//  Description: Returns the custom event queue to be used for
//               throwing done events from intervals as they finish.
//////////////////////////////////////////////////////////////////// 1 4 this 3 368  
77 14 Dtool_SpsCyh7A 6 84 342 0 14 Dtool_SpsCyh7A 1079 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::add_c_interval
//       Access: Published
//  Description: Adds the interval to the manager, and returns a
//               unique index for the interval.  This index will be
//               unique among all the currently added intervals, but
//               not unique across all intervals ever added to the
//               manager.  The maximum index value will never exceed
//               the maximum number of intervals added at any given
//               time.
//
//               If the external flag is true, the interval is
//               understood to also be stored in the scripting
//               language data structures.  In this case, it will be
//               available for information returned by
//               get_next_event() and get_next_removal().  If external
//               is false, the interval's index will never be returned
//               by these two functions.
//////////////////////////////////////////////////////////////////// 3 4 this 3 339  8 interval 1 337  8 external 1 317  
78 14 Dtool_SpsCA0H3 6 85 342 0 14 Dtool_SpsCA0H3 356 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::find_c_interval
//       Access: Published
//  Description: Returns the index associated with the named interval,
//               if there is such an interval, or -1 if there is not.
//////////////////////////////////////////////////////////////////// 2 4 this 3 368  4 name 1 335  
79 14 Dtool_SpsCnvsF 7 86 337 0 14 Dtool_SpsCnvsF 285 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_c_interval
//       Access: Published
//  Description: Returns the interval associated with the given index.
//////////////////////////////////////////////////////////////////// 2 4 this 3 368  5 index 1 342  
80 14 Dtool_SpsCPxys 4 87 338 0 14 Dtool_SpsCPxys 472 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::remove_c_interval
//       Access: Published
//  Description: Removes the indicated interval from the queue
//               immediately.  It will not be returned from
//               get_next_removal(), and none of its pending events,
//               if any, will be returned by get_next_event().
//////////////////////////////////////////////////////////////////// 2 4 this 3 339  5 index 1 342  
81 14 Dtool_SpsCwZTK 6 88 342 0 14 Dtool_SpsCwZTK 605 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::interrupt
//       Access: Published
//  Description: Pauses or finishes (removes from the active queue)
//               all intervals tagged with auto_pause or auto_finish
//               set to true.  These are intervals that someone fired
//               up but won't necessarily expect to clean up; they can
//               be interrupted at will when necessary.
//
//               Returns the number of intervals affected.
//////////////////////////////////////////////////////////////////// 1 4 this 3 339  
82 14 Dtool_SpsCW9zD 6 89 342 0 14 Dtool_SpsCW9zD 284 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_num_intervals
//       Access: Published
//  Description: Returns the number of currently active intervals.
//////////////////////////////////////////////////////////////////// 1 4 this 3 368  
83 14 Dtool_SpsCrnjb 6 90 342 0 14 Dtool_SpsCrnjb 591 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_max_index
//       Access: Published
//  Description: Returns one more than the largest interval index
//               number in the manager.  If you walk through all the
//               values between (0, get_max_index()] and call
//               get_c_interval() on each number, you will retrieve
//               all of the managed intervals (and possibly a number
//               of NULL pointers as well).
//////////////////////////////////////////////////////////////////// 1 4 this 3 368  
84 14 Dtool_SpsCjQ_p 4 91 338 0 14 Dtool_SpsCjQ_p 771 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::step
//       Access: Published
//  Description: This should be called every frame to do the
//               processing for all the active intervals.  It will
//               call step_play() for each interval that has been
//               added and that has not yet been removed.
//
//               After each call to step(), the scripting language
//               should call get_next_event() and get_next_removal()
//               repeatedly to process all the high-level
//               (e.g. Python-interval-based) events and to manage the
//               high-level list of intervals.
//////////////////////////////////////////////////////////////////// 1 4 this 3 339  
85 14 Dtool_SpsCgEV_ 6 92 342 0 14 Dtool_SpsCgEV_ 911 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_next_event
//       Access: Published
//  Description: This should be called by the scripting language after
//               each call to step().  It returns the index number of
//               the next interval that has events requiring servicing
//               by the scripting language, or -1 if no more intervals
//               have any events pending.
//
//               If this function returns something other than -1, it
//               is the scripting language's responsibility to query
//               the indicated interval for its next event via
//               get_event_index(), and eventually pop_event().
//
//               Then get_next_event() should be called again until it
//               returns -1.
//////////////////////////////////////////////////////////////////// 1 4 this 3 339  
86 14 Dtool_SpsCyDVA 6 93 342 0 14 Dtool_SpsCyDVA 694 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_next_removal
//       Access: Published
//  Description: This should be called by the scripting language after
//               each call to step().  It returns the index number of
//               an interval that was recently removed, or -1 if no
//               intervals were removed.
//
//               If this returns something other than -1, the
//               scripting language should clean up its own data
//               structures accordingly, and then call
//               get_next_removal() again.
//////////////////////////////////////////////////////////////////// 1 4 this 3 339  
87 14 Dtool_SpsCJ5QE 4 94 338 0 14 Dtool_SpsCJ5QE 224 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::output
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 368  3 out 1 340  
88 14 Dtool_SpsCzWze 4 95 338 0 14 Dtool_SpsCzWze 223 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::write
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 368  3 out 1 340  
89 14 Dtool_SpsCTP38 6 96 339 0 14 Dtool_SpsCTP38 319 ////////////////////////////////////////////////////////////////////
//     Function: CIntervalManager::get_global_ptr
//       Access: Published, Static
//  Description: Returns the pointer to the one global
//               CIntervalManager object.
//////////////////////////////////////////////////////////////////// 0 
90 14 Dtool_SpsCg1iu 6 99 324 0 14 Dtool_SpsCg1iu 411 ////////////////////////////////////////////////////////////////////
//     Function: CLerpInterval::get_blend_type
//       Access: Published
//  Description: Returns the blend type specified for the interval.
//               This controls how the linear interpolation behaves
//               near the beginning and end of the lerp period.
//////////////////////////////////////////////////////////////////// 1 4 this 3 370  
91 14 Dtool_SpsCHWfc 6 100 324 0 14 Dtool_SpsCHWfc 403 ////////////////////////////////////////////////////////////////////
//     Function: CLerpInterval::string_blend_type
//       Access: Published, Static
//  Description: Returns the BlendType enumerated value corresponding
//               to the indicated string, or BT_invalid if the string
//               doesn't match anything.
//////////////////////////////////////////////////////////////////// 1 10 blend_type 1 335  
92 14 Dtool_SpsCFioW 7 101 344 0 14 Dtool_SpsCFioW 0 0 
93 14 Dtool_SpsCZ1mi 7 104 372 252 14 Dtool_SpsCZ1mi 735 // Filename: cLerpAnimEffectInterval.I
// Created by:  drose (27Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CLerpAnimEffectInterval::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 3 4 name 1 335  8 duration 1 336  10 blend_type 1 324  
94 14 Dtool_SpsCPyvp 4 105 338 0 14 Dtool_SpsCPyvp 573 ////////////////////////////////////////////////////////////////////
//     Function: CLerpAnimEffectInterval::add_control
//       Access: Published
//  Description: Adds another AnimControl to the list of AnimControls
//               affected by the lerp.  This control will be lerped
//               from begin_effect to end_effect over the period of
//               the lerp.
//
//               The AnimControl name parameter is only used when
//               formatting the interval for output.
//////////////////////////////////////////////////////////////////// 5 4 this 3 372  7 control 1 373  4 name 1 335  12 begin_effect 1 375  10 end_effect 1 375  
95 14 Dtool_SpsCxulU 7 106 344 0 14 Dtool_SpsCxulU 0 0 
96 14 Dtool_SpsCdIA4 7 109 376 280 14 Dtool_SpsCdIA4 1792 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::Constructor
//       Access: Published
//  Description: Constructs a lerp interval that will lerp some
//               properties on the indicated node, possibly relative
//               to the indicated other node (if other is nonempty).
//
//               You must call set_end_pos(), etc. for the various
//               properties you wish to lerp before the first call to
//               priv_initialize().  If you want to set a starting value
//               for any of the properties, you may call
//               set_start_pos(), etc.; otherwise, the starting value
//               is taken from the actual node's value at the time the
//               lerp is performed.
//
//               The starting values may be explicitly specified or
//               omitted.  The value of bake_in_start determines the
//               behavior if the starting values are omitted.  If
//               bake_in_start is true, the values are obtained the
//               first time the lerp runs, and thenceforth are stored
//               within the interval.  If bake_in_start is false, the
//               starting value is computed each frame, based on
//               assuming the current value represents the value set
//               from the last time the interval was run.  This
//               "smart" behavior allows code to manipulate the object
//               event while it is being lerped, and the lerp
//               continues to apply in a sensible way.
//
//               If fluid is true, the prev_transform is not adjusted
//               by the lerp; otherwise, it is reset.
//////////////////////////////////////////////////////////////////// 7 4 name 1 335  8 duration 1 336  10 blend_type 1 324  13 bake_in_start 1 317  5 fluid 1 317  4 node 1 348  5 other 1 348  
97 14 Dtool_SpsC9PvW 6 110 348 0 14 Dtool_SpsC9PvW 758 // Filename: cLerpNodePathInterval.I
// Created by:  drose (27Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::get_node
//       Access: Published
//  Description: Returns the node being lerped.
//////////////////////////////////////////////////////////////////// 1 4 this 3 377  
98 14 Dtool_SpsCSM_v 6 111 348 0 14 Dtool_SpsCSM_v 451 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::get_other
//       Access: Published
//  Description: Returns the "other" node, which the lerped node is
//               being moved relative to.  If this is an empty node
//               path, the lerped node is being moved in its own
//               coordinate system.
//////////////////////////////////////////////////////////////////// 1 4 this 3 377  
99 14 Dtool_SpsCaRxY 4 112 338 0 14 Dtool_SpsCaRxY 547 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_pos
//       Access: Published
//  Description: Indicates the initial position of the lerped node.
//               This is meaningful only if set_end_pos() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               position at the time the lerp is performed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  3 pos 1 351  
100 14 Dtool_SpsCJiNY 4 113 338 0 14 Dtool_SpsCJiNY 531 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_pos
//       Access: Published
//  Description: Indicates that the position of the node should be
//               lerped, and specifies the final position of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's position will not be
//               affected by the lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  3 pos 1 351  
101 14 Dtool_SpsClyYW 4 114 338 0 14 Dtool_SpsClyYW 589 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_hpr
//       Access: Published
//  Description: Indicates the initial rotation of the lerped node.
//               This is meaningful only if either set_end_hpr() or
//               set_end_quat() is also called.  This parameter is
//               optional; if unspecified, the value will be taken
//               from the node's actual rotation at the time the lerp
//               is performed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  3 hpr 1 351  
102 14 Dtool_SpsCRVh4 4 115 338 0 14 Dtool_SpsCRVh4 735 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_hpr
//       Access: Published
//  Description: Indicates that the rotation of the node should be
//               lerped, and specifies the final rotation of the node.
//               This should be called before priv_initialize().
//
//               This special function is overloaded to accept a
//               quaternion, even though the function name is
//               set_end_hpr().  The quaternion will be implicitly
//               converted to a HPR trio, and the lerp will be
//               performed in HPR space, componentwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  4 quat 1 379  
103 14 Dtool_SpsCrohJ 4 115 338 0 14 Dtool_SpsCrohJ 632 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_hpr
//       Access: Published
//  Description: Indicates that the rotation of the node should be
//               lerped, and specifies the final rotation of the node.
//               This should be called before priv_initialize().
//
//               This replaces a previous call to set_end_quat().  If
//               neither set_end_hpr() nor set_end_quat() is called,
//               the node's rotation will not be affected by the lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  3 hpr 1 351  
104 14 Dtool_SpsCc5Xe 4 116 338 0 14 Dtool_SpsCc5Xe 590 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_quat
//       Access: Published
//  Description: Indicates the initial rotation of the lerped node.
//               This is meaningful only if either set_end_quat() or
//               set_end_hpr() is also called.  This parameter is
//               optional; if unspecified, the value will be taken
//               from the node's actual rotation at the time the lerp
//               is performed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  4 quat 1 379  
105 14 Dtool_SpsCt__n 4 117 338 0 14 Dtool_SpsCt__n 632 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_quat
//       Access: Published
//  Description: Indicates that the rotation of the node should be
//               lerped, and specifies the final rotation of the node.
//               This should be called before priv_initialize().
//
//               This replaces a previous call to set_end_hpr().  If
//               neither set_end_quat() nor set_end_hpr() is called,
//               the node's rotation will not be affected by the lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  4 quat 1 379  
106 14 Dtool_SpsCGCRI 4 117 338 0 14 Dtool_SpsCGCRI 955 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_quat
//       Access: Published
//  Description: Indicates that the rotation of the node should be
//               lerped, and specifies the final rotation of the node.
//               This should be called before priv_initialize().
//
//               This replaces a previous call to set_end_hpr().  If
//               neither set_end_quat() nor set_end_hpr() is called,
//               the node's rotation will not be affected by the lerp.
//
//               This special function is overloaded to accept a HPR
//               trio, even though the function name is
//               set_end_quat().  The HPR will be implicitly converted
//               to a quaternion, and the lerp will be performed in
//               quaternion space, as a spherical lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  3 hpr 1 351  
107 14 Dtool_SpsCPMwu 4 118 338 0 14 Dtool_SpsCPMwu 545 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_scale
//       Access: Published
//  Description: Indicates the initial scale of the lerped node.
//               This is meaningful only if set_end_scale() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               scale at the time the lerp is performed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  5 scale 1 351  
108 14 Dtool_SpsCLfsN 4 118 338 0 14 Dtool_SpsCLfsN 545 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_scale
//       Access: Published
//  Description: Indicates the initial scale of the lerped node.
//               This is meaningful only if set_end_scale() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               scale at the time the lerp is performed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  5 scale 1 375  
109 14 Dtool_SpsCu_6i 4 119 338 0 14 Dtool_SpsCu_6i 524 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_scale
//       Access: Published
//  Description: Indicates that the scale of the node should be
//               lerped, and specifies the final scale of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's scale will not be
//               affected by the lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  5 scale 1 351  
110 14 Dtool_SpsCBCOk 4 119 338 0 14 Dtool_SpsCBCOk 524 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_scale
//       Access: Published
//  Description: Indicates that the scale of the node should be
//               lerped, and specifies the final scale of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's scale will not be
//               affected by the lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  5 scale 1 375  
111 14 Dtool_SpsCyKML 4 120 338 0 14 Dtool_SpsCyKML 545 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_shear
//       Access: Published
//  Description: Indicates the initial shear of the lerped node.
//               This is meaningful only if set_end_shear() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               shear at the time the lerp is performed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  5 shear 1 351  
112 14 Dtool_SpsC1jlK 4 121 338 0 14 Dtool_SpsC1jlK 524 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_shear
//       Access: Published
//  Description: Indicates that the shear of the node should be
//               lerped, and specifies the final shear of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's shear will not be
//               affected by the lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  5 shear 1 351  
113 14 Dtool_SpsCt8Tw 4 122 338 0 14 Dtool_SpsCt8Tw 545 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_color
//       Access: Published
//  Description: Indicates the initial color of the lerped node.
//               This is meaningful only if set_end_color() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               color at the time the lerp is performed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  5 color 1 382  
114 14 Dtool_SpsCUGzY 4 123 338 0 14 Dtool_SpsCUGzY 524 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_color
//       Access: Published
//  Description: Indicates that the color of the node should be
//               lerped, and specifies the final color of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's color will not be
//               affected by the lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  5 color 1 382  
115 14 Dtool_SpsCJuh7 4 124 338 0 14 Dtool_SpsCJuh7 569 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_color_scale
//       Access: Published
//  Description: Indicates the initial color scale of the lerped node.
//               This is meaningful only if set_end_color_scale() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               color scale at the time the lerp is performed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  11 color_scale 1 382  
116 14 Dtool_SpsCUY_S 4 125 338 0 14 Dtool_SpsCUY_S 548 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_color_scale
//       Access: Published
//  Description: Indicates that the color scale of the node should be
//               lerped, and specifies the final color scale of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's color scale will not be
//               affected by the lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  11 color_scale 1 382  
117 14 Dtool_SpsCVJm6 4 126 338 0 14 Dtool_SpsCVJm6 426 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_texture_stage
//       Access: Published
//  Description: Indicates the texture stage that is adjusted by
//               tex_offset, tex_rotate, and/or tex_scale.  If this is
//               not set, the default is the default texture stage.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  5 stage 1 385  
118 14 Dtool_SpsCQfKP 4 127 338 0 14 Dtool_SpsCQfKP 563 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_tex_offset
//       Access: Published
//  Description: Indicates the initial UV offset of the lerped node.
//               This is meaningful only if set_end_tex_offset() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               UV offset at the time the lerp is performed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  10 tex_offset 1 387  
119 14 Dtool_SpsC_9Uf 4 128 338 0 14 Dtool_SpsC_9Uf 541 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_tex_offset
//       Access: Published
//  Description: Indicates that the UV offset of the node should be
//               lerped, and specifies the final UV offset of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's UV offset will not be
//               affected by the lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  10 tex_offset 1 387  
120 14 Dtool_SpsCwlJM 4 129 338 0 14 Dtool_SpsCwlJM 563 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_tex_rotate
//       Access: Published
//  Description: Indicates the initial UV rotate of the lerped node.
//               This is meaningful only if set_end_tex_rotate() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               UV rotate at the time the lerp is performed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  10 tex_rotate 1 375  
121 14 Dtool_SpsCp1uF 4 130 338 0 14 Dtool_SpsCp1uF 541 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_tex_rotate
//       Access: Published
//  Description: Indicates that the UV rotate of the node should be
//               lerped, and specifies the final UV rotate of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's UV rotate will not be
//               affected by the lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  10 tex_rotate 1 375  
122 14 Dtool_SpsCr5am 4 131 338 0 14 Dtool_SpsCr5am 559 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_start_tex_scale
//       Access: Published
//  Description: Indicates the initial UV scale of the lerped node.
//               This is meaningful only if set_end_tex_scale() is also
//               called.  This parameter is optional; if unspecified,
//               the value will be taken from the node's actual
//               UV scale at the time the lerp is performed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  9 tex_scale 1 387  
123 14 Dtool_SpsC8QnN 4 132 338 0 14 Dtool_SpsC8QnN 537 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_end_tex_scale
//       Access: Published
//  Description: Indicates that the UV scale of the node should be
//               lerped, and specifies the final UV scale of the node.
//               This should be called before priv_initialize().  If this
//               is not called, the node's UV scale will not be
//               affected by the lerp.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  9 tex_scale 1 387  
124 14 Dtool_SpsCaaze 4 133 338 0 14 Dtool_SpsCaaze 623 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::set_override
//       Access: Published
//  Description: Changes the override value that will be associated
//               with any state changes applied by the lerp.  If this
//               lerp is changing state (for instance, a color lerp or
//               a tex matrix lerp), then the new attributes created
//               by this lerp will be assigned the indicated override
//               value when they are applied to the node.
//////////////////////////////////////////////////////////////////// 2 4 this 3 376  8 override 1 342  
125 14 Dtool_SpsCj9kr 6 134 342 0 14 Dtool_SpsCj9kr 384 ////////////////////////////////////////////////////////////////////
//     Function: CLerpNodePathInterval::get_override
//       Access: Published
//  Description: Returns the override value that will be associated
//               with any state changes applied by the lerp.  See
//               set_override().
//////////////////////////////////////////////////////////////////// 1 4 this 3 377  
126 14 Dtool_SpsCdTLY 7 135 344 0 14 Dtool_SpsCdTLY 0 0 
127 14 Dtool_SpsCfll2 7 138 390 0 14 Dtool_SpsCfll2 226 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 name 1 335  
128 14 Dtool_SpsCxSCe 4 140 338 0 14 Dtool_SpsCxSCe 1201 // Filename: cMetaInterval.I
// Created by:  drose (27Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::set_precision
//       Access: Published
//  Description: Indicates the precision with which time measurements
//               are compared.  For numerical accuracy, all
//               floating-point time values are converted to integer
//               values internally by scaling by the precision factor.
//               The larger the number given here, the smaller the
//               delta of time that can be differentiated; the
//               limit is the maximum integer that can be represented
//               in the system.
//////////////////////////////////////////////////////////////////// 2 4 this 3 390  9 precision 1 336  
129 14 Dtool_SpsC5PcZ 6 141 336 0 14 Dtool_SpsC5PcZ 331 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_precision
//       Access: Published
//  Description: Returns the precision with which time measurements
//               are compared.  See set_precision().
//////////////////////////////////////////////////////////////////// 1 4 this 3 391  
130 14 Dtool_SpsCS3bp 4 142 338 0 14 Dtool_SpsCS3bp 314 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::clear_intervals
//       Access: Published
//  Description: Resets the list of intervals and prepares for
//               receiving a new list.
//////////////////////////////////////////////////////////////////// 1 4 this 3 390  
131 14 Dtool_SpsCe1kF 6 143 342 0 14 Dtool_SpsCe1kF 647 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::push_level
//       Access: Published
//  Description: Marks the beginning of a nested level of child
//               intervals.  Within the nested level, a RelativeStart
//               time of RS_level_begin refers to the start of the
//               level, and the first interval added within the level
//               is always relative to the start of the level.
//
//               The return value is the index of the def entry
//               created by this push.
//////////////////////////////////////////////////////////////////// 4 4 this 3 390  4 name 1 335  8 rel_time 1 336  6 rel_to 1 328  
132 14 Dtool_SpsC8fyX 6 144 342 0 14 Dtool_SpsC8fyX 512 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::add_c_interval
//       Access: Published
//  Description: Adds a new CInterval to the list.  The interval will
//               be played when the indicated time (relative to the
//               given point) has been reached.
//
//               The return value is the index of the def entry
//               representing the new interval.
//////////////////////////////////////////////////////////////////// 4 4 this 3 390  10 c_interval 1 337  8 rel_time 1 336  6 rel_to 1 328  
133 14 Dtool_SpsChhyN 6 144 342 0 14 Dtool_SpsChhyN 512 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::add_c_interval
//       Access: Published
//  Description: Adds a new CInterval to the list.  The interval will
//               be played when the indicated time (relative to the
//               given point) has been reached.
//
//               The return value is the index of the def entry
//               representing the new interval.
//////////////////////////////////////////////////////////////////// 3 4 this 3 390  10 c_interval 1 337  8 rel_time 1 336  
134 14 Dtool_SpsCHpFi 6 144 342 0 14 Dtool_SpsCHpFi 512 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::add_c_interval
//       Access: Published
//  Description: Adds a new CInterval to the list.  The interval will
//               be played when the indicated time (relative to the
//               given point) has been reached.
//
//               The return value is the index of the def entry
//               representing the new interval.
//////////////////////////////////////////////////////////////////// 2 4 this 3 390  10 c_interval 1 337  
135 14 Dtool_SpsCsI0L 6 145 342 0 14 Dtool_SpsCsI0L 1156 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::add_ext_index
//       Access: Published
//  Description: Adds a new external interval to the list.  This
//               represents some object in the external scripting
//               language that has properties similar to a CInterval
//               (for instance, a Python Interval object).
//
//               The CMetaInterval object cannot play this external
//               interval directly, but it records a placeholder for
//               it and will ask the scripting language to play it
//               when it is time, via is_event_ready() and related
//               methods.
//
//               The ext_index number itself is simply a handle that
//               the scripting language makes up and associates with
//               its interval object somehow.  The CMetaInterval
//               object does not attempt to interpret this value.
//
//               The return value is the index of the def entry
//               representing the new interval.
//////////////////////////////////////////////////////////////////// 7 4 this 3 390  9 ext_index 1 342  4 name 1 335  8 duration 1 336  10 open_ended 1 317  8 rel_time 1 336  6 rel_to 1 328  
136 14 Dtool_SpsCAQho 6 146 342 0 14 Dtool_SpsCAQho 645 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::pop_level
//       Access: Published
//  Description: Finishes a level marked by a previous call to
//               push_level(), and returns to the previous level.
//
//               If the duration is not negative, it represents a
//               phony duration to assign to the level, for the
//               purposes of sequencing later intervals.  Otherwise,
//               the level's duration is computed based on the
//               intervals within the level.
//////////////////////////////////////////////////////////////////// 2 4 this 3 390  8 duration 1 336  
137 14 Dtool_SpsCcB29 6 146 342 0 14 Dtool_SpsCcB29 645 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::pop_level
//       Access: Published
//  Description: Finishes a level marked by a previous call to
//               push_level(), and returns to the previous level.
//
//               If the duration is not negative, it represents a
//               phony duration to assign to the level, for the
//               purposes of sequencing later intervals.  Otherwise,
//               the level's duration is computed based on the
//               intervals within the level.
//////////////////////////////////////////////////////////////////// 1 4 this 3 390  
138 14 Dtool_SpsCbNvh 6 147 317 0 14 Dtool_SpsCbNvh 824 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::set_interval_start_time
//       Access: Published
//  Description: Adjusts the start time of the child interval with the
//               given name, if found.  This may be either a C++
//               interval added via add_c_interval(), or an external
//               interval added via add_ext_index(); the name must
//               match exactly.
//
//               If the interval is found, its start time is adjusted,
//               and all subsequent intervals are adjusting
//               accordingly, and true is returned.  If a matching
//               interval is not found, nothing is changed and false
//               is returned.
//////////////////////////////////////////////////////////////////// 4 4 this 3 390  4 name 1 335  8 rel_time 1 336  6 rel_to 1 328  
139 14 Dtool_SpsCDRqF 6 147 317 0 14 Dtool_SpsCDRqF 824 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::set_interval_start_time
//       Access: Published
//  Description: Adjusts the start time of the child interval with the
//               given name, if found.  This may be either a C++
//               interval added via add_c_interval(), or an external
//               interval added via add_ext_index(); the name must
//               match exactly.
//
//               If the interval is found, its start time is adjusted,
//               and all subsequent intervals are adjusting
//               accordingly, and true is returned.  If a matching
//               interval is not found, nothing is changed and false
//               is returned.
//////////////////////////////////////////////////////////////////// 3 4 this 3 390  4 name 1 335  8 rel_time 1 336  
140 14 Dtool_SpsCnjRJ 6 148 336 0 14 Dtool_SpsCnjRJ 451 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_interval_start_time
//       Access: Published
//  Description: Returns the actual start time, relative to the
//               beginning of the interval, of the child interval with
//               the given name, if found, or -1 if the interval is
//               not found.
//////////////////////////////////////////////////////////////////// 2 4 this 3 391  4 name 1 335  
141 14 Dtool_SpsCwxHv 6 149 336 0 14 Dtool_SpsCwxHv 447 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_interval_end_time
//       Access: Published
//  Description: Returns the actual end time, relative to the
//               beginning of the interval, of the child interval with
//               the given name, if found, or -1 if the interval is
//               not found.
//////////////////////////////////////////////////////////////////// 2 4 this 3 391  4 name 1 335  
142 14 Dtool_SpsC4MwM 6 151 342 0 14 Dtool_SpsC4MwM 359 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_num_defs
//       Access: Published
//  Description: Returns the number of interval and push/pop
//               definitions that have been added to the meta
//               interval.
//////////////////////////////////////////////////////////////////// 1 4 this 3 391  
143 14 Dtool_SpsCleqy 6 152 329 0 14 Dtool_SpsCleqy 312 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_def_type
//       Access: Published
//  Description: Returns the type of the nth interval definition that
//               has been added.
//////////////////////////////////////////////////////////////////// 2 4 this 3 391  1 n 1 342  
144 14 Dtool_SpsClcyM 7 153 337 0 14 Dtool_SpsClcyM 409 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_c_interval
//       Access: Published
//  Description: Return the CInterval pointer associated with the nth
//               interval definition.  It is only valid to call this
//               if get_def_type(n) returns DT_c_interval.
//////////////////////////////////////////////////////////////////// 2 4 this 3 391  1 n 1 342  
145 14 Dtool_SpsCDZwS 6 154 342 0 14 Dtool_SpsCDZwS 420 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_ext_index
//       Access: Published
//  Description: Return the external interval index number associated
//               with the nth interval definition.  It is only valid
//               to call this if get_def_type(n) returns DT_ext_index.
//////////////////////////////////////////////////////////////////// 2 4 this 3 391  1 n 1 342  
146 14 Dtool_SpsCG_g4 6 155 317 0 14 Dtool_SpsCG_g4 544 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::is_event_ready
//       Access: Published
//  Description: Returns true if a recent call to priv_initialize(),
//               priv_step(), or priv_finalize() has left some external
//               intervals ready to play.  If this returns true, call
//               get_event_index(), get_event_t(), and pop_event() to
//               retrieve the relevant information.
//////////////////////////////////////////////////////////////////// 1 4 this 3 390  
147 14 Dtool_SpsCdJvv 6 156 342 0 14 Dtool_SpsCdJvv 444 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_event_index
//       Access: Published
//  Description: If a previous call to is_event_ready() returned
//               true, this returns the index number (added via
//               add_event_index()) of the external interval that needs
//               to be played.
//////////////////////////////////////////////////////////////////// 1 4 this 3 391  
148 14 Dtool_SpsCPQNU 6 157 336 0 14 Dtool_SpsCPQNU 380 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_event_t
//       Access: Published
//  Description: If a previous call to is_event_ready() returned
//               true, this returns the t value that should be fed to
//               the given interval.
//////////////////////////////////////////////////////////////////// 1 4 this 3 391  
149 14 Dtool_SpsCsP8v 6 158 314 0 14 Dtool_SpsCsP8v 410 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::get_event_type
//       Access: Published
//  Description: If a previous call to is_event_ready() returned
//               true, this returns the type of the event (initialize,
//               step, finalize, etc.) for the given interval.
//////////////////////////////////////////////////////////////////// 1 4 this 3 391  
150 14 Dtool_SpsC4v7o 4 159 338 0 14 Dtool_SpsC4v7o 591 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::pop_event
//       Access: Published
//  Description: Acknowledges that the external interval on the top of
//               the queue has been extracted, and is about to be
//               serviced by the scripting language.  This prepares
//               the interval so the next call to is_event_ready()
//               will return information about the next external
//               interval on the queue, if any.
//////////////////////////////////////////////////////////////////// 1 4 this 3 390  
151 14 Dtool_SpsCXzrj 4 160 338 0 14 Dtool_SpsCXzrj 302 ////////////////////////////////////////////////////////////////////
//     Function: CMetaInterval::timeline
//       Access: Published
//  Description: Outputs a list of all events in the order in which
//               they occur.
//////////////////////////////////////////////////////////////////// 2 4 this 3 391  3 out 1 340  
152 14 Dtool_SpsCQy_U 7 161 344 0 14 Dtool_SpsCQy_U 0 0 
153 14 Dtool_SpsCVO63 7 163 393 305 14 Dtool_SpsCVO63 225 ////////////////////////////////////////////////////////////////////
//     Function: HideInterval::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 node 1 348  4 name 1 335  
154 14 Dtool_SpsC866V 7 163 393 305 14 Dtool_SpsC866V 225 ////////////////////////////////////////////////////////////////////
//     Function: HideInterval::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 node 1 348  
155 14 Dtool_SpsCVV6X 7 164 344 0 14 Dtool_SpsCVV6X 0 0 
156 14 Dtool_SpsCNLk_ 7 167 394 308 14 Dtool_SpsCNLk_ 225 ////////////////////////////////////////////////////////////////////
//     Function: ShowInterval::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 node 1 348  4 name 1 335  
157 14 Dtool_SpsCxxld 7 167 394 308 14 Dtool_SpsCxxld 225 ////////////////////////////////////////////////////////////////////
//     Function: ShowInterval::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 node 1 348  
158 14 Dtool_SpsC1PEe 7 168 344 0 14 Dtool_SpsC1PEe 0 0 
159 14 Dtool_SpsCJUNH 7 171 395 311 14 Dtool_SpsCJUNH 827 // Filename: waitInterval.I
// Created by:  drose (12Sep02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: WaitInterval::Constructor
//       Access: Published
//  Description: All Wait intervals have the same name.  No one really
//               cares if their names are unique, after all.
//////////////////////////////////////////////////////////////////// 1 8 duration 1 336  
160 14 Dtool_SpsCowFS 7 172 344 0 14 Dtool_SpsCowFS 0 0 
84
312 9 CInterval 75777 9 CInterval 9 CInterval 0 0 0 0 0 0 43 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 0 0 1 0 313 0 0 0 2 314 315 780
////////////////////////////////////////////////////////////////////
//       Class : CInterval
// Description : The base class for timeline components.  A CInterval
//               represents a single action, event, or collection of
//               nested intervals that will be performed at some
//               specific time or over a period of time.
//
//               This is essentially similar to the Python "Interval"
//               class, but it is implemented in C++ (hence the name).
//               Intervals that may be implemented in C++ will inherit
//               from this class; Intervals that must be implemented
//               in Python will inherit from the similar Python class.
////////////////////////////////////////////////////////////////////

313 19 TypedReferenceCount 2049 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 710
////////////////////////////////////////////////////////////////////
//       Class : TypedReferenceCount
// Description : A base class for things which need to inherit from
//               both TypedObject and from ReferenceCount.  It's
//               convenient to define this intermediate base class
//               instead of multiply inheriting from the two classes
//               each time they are needed, so that we can sensibly
//               pass around pointers to things which are both
//               TypedObjects and ReferenceCounters.
//               
//               See also TypedObject for detailed instructions.
////////////////////////////////////////////////////////////////////

314 9 EventType 794624 20 CInterval::EventType 20 CInterval::EventType 312 0 0 0 0 0 0 0 0 0 8 13 ET_initialize 24 CInterval::ET_initialize 0 10 ET_instant 21 CInterval::ET_instant 1 7 ET_step 18 CInterval::ET_step 2 11 ET_finalize 22 CInterval::ET_finalize 3 21 ET_reverse_initialize 32 CInterval::ET_reverse_initialize 4 18 ET_reverse_instant 29 CInterval::ET_reverse_instant 5 19 ET_reverse_finalize 30 CInterval::ET_reverse_finalize 6 12 ET_interrupt 23 CInterval::ET_interrupt 7 0 0

315 5 State 794624 16 CInterval::State 16 CInterval::State 312 0 0 0 0 0 0 0 0 0 4 9 S_initial 20 CInterval::S_initial 0 9 S_started 20 CInterval::S_started 1 8 S_paused 19 CInterval::S_paused 2 7 S_final 18 CInterval::S_final 3 0 0

316 19 CConstraintInterval 141313 19 CConstraintInterval 19 CConstraintInterval 0 0 0 0 207 1 396 1 206 0 0 1 0 312 0 0 0 0 300
////////////////////////////////////////////////////////////////////
//       Class : CConstraintInterval
// Description : The base class for a family of intervals that
//               constrain some property to a value over time.
////////////////////////////////////////////////////////////////////

317 4 bool 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

318 21 CConstrainHprInterval 141313 21 CConstrainHprInterval 21 CConstrainHprInterval 0 0 0 1 208 212 0 3 209 210 211 0 0 1 0 316 0 0 0 0 311
////////////////////////////////////////////////////////////////////
//       Class : CConstrainHprInterval
// Description : A constraint interval that will constrain the
//               orientation of one node to the orientation of another.
////////////////////////////////////////////////////////////////////

319 24 CConstrainPosHprInterval 141313 24 CConstrainPosHprInterval 24 CConstrainPosHprInterval 0 0 0 1 213 217 0 3 214 215 216 0 0 1 0 316 0 0 0 0 357
////////////////////////////////////////////////////////////////////
//       Class : CConstrainPosHprInterval
// Description : A constraint interval that will constrain the
//               position and orientation of one node to the
//               position and orientation of another.
////////////////////////////////////////////////////////////////////

320 21 CConstrainPosInterval 141313 21 CConstrainPosInterval 21 CConstrainPosInterval 0 0 0 1 218 222 0 3 219 220 221 0 0 1 0 316 0 0 0 0 305
////////////////////////////////////////////////////////////////////
//       Class : CConstrainPosInterval
// Description : A constraint interval that will constrain the
//               position of one node to the position of another.
////////////////////////////////////////////////////////////////////

321 27 CConstrainTransformInterval 141313 27 CConstrainTransformInterval 27 CConstrainTransformInterval 0 0 0 1 223 227 0 3 224 225 226 0 0 1 0 316 0 0 0 0 313
////////////////////////////////////////////////////////////////////
//       Class : CConstrainTransformInterval
// Description : A constraint interval that will constrain the
//               transform of one node to the transform of another.
////////////////////////////////////////////////////////////////////

322 16 CIntervalManager 26625 16 CIntervalManager 16 CIntervalManager 0 0 0 1 228 229 0 15 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 0 0 0 0 0 777
////////////////////////////////////////////////////////////////////
//       Class : CIntervalManager
// Description : This object holds a number of currently-playing
//               intervals and is responsible for advancing them each
//               frame as needed.
//
//               There is normally only one IntervalManager object in
//               the world, and it is the responsibility of the
//               scripting language to call step() on this object once
//               each frame, and to then process the events indicated by
//               get_next_event().  
//
//               It is also possible to create multiple
//               IntervalManager objects for special needs.
////////////////////////////////////////////////////////////////////

323 13 CLerpInterval 141313 13 CLerpInterval 13 CLerpInterval 0 0 0 0 248 0 3 245 246 247 0 0 1 0 312 0 0 0 1 324 324
////////////////////////////////////////////////////////////////////
//       Class : CLerpInterval
// Description : The base class for a family of intervals that
//               linearly interpolate one or more numeric values over
//               time.
////////////////////////////////////////////////////////////////////

324 9 BlendType 794624 24 CLerpInterval::BlendType 24 CLerpInterval::BlendType 323 0 0 0 0 0 0 0 0 0 5 11 BT_no_blend 26 CLerpInterval::BT_no_blend 0 10 BT_ease_in 25 CLerpInterval::BT_ease_in 1 11 BT_ease_out 26 CLerpInterval::BT_ease_out 2 14 BT_ease_in_out 29 CLerpInterval::BT_ease_in_out 3 10 BT_invalid 25 CLerpInterval::BT_invalid 4 0 0

325 23 CLerpAnimEffectInterval 141313 23 CLerpAnimEffectInterval 23 CLerpAnimEffectInterval 0 0 0 1 249 252 0 2 250 251 0 0 1 0 323 0 0 0 0 649
////////////////////////////////////////////////////////////////////
//       Class : CLerpAnimEffectInterval
// Description : This interval lerps between different amounts of
//               control effects for various AnimControls that might
//               be playing on an actor.  It's used to change the
//               blending amount between multiple animations.
//
//               The idea is to start all the animations playing
//               first, then use a CLerpAnimEffectInterval to adjust
//               the degree to which each animation affects the actor.
////////////////////////////////////////////////////////////////////

326 21 CLerpNodePathInterval 141313 21 CLerpNodePathInterval 21 CLerpNodePathInterval 0 0 0 1 253 280 0 26 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 0 0 1 0 323 0 0 0 0 303
////////////////////////////////////////////////////////////////////
//       Class : CLerpNodePathInterval
// Description : An interval that lerps one or more properties (like
//               pos, hpr, etc.) on a NodePath over time.
////////////////////////////////////////////////////////////////////

327 13 CMetaInterval 75777 13 CMetaInterval 13 CMetaInterval 0 0 0 1 281 0 0 21 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 0 0 1 0 312 0 0 0 2 328 329 0

328 13 RelativeStart 794624 28 CMetaInterval::RelativeStart 28 CMetaInterval::RelativeStart 327 0 0 0 0 0 0 0 0 0 3 15 RS_previous_end 30 CMetaInterval::RS_previous_end 0 17 RS_previous_begin 32 CMetaInterval::RS_previous_begin 1 14 RS_level_begin 29 CMetaInterval::RS_level_begin 2 0 0

329 7 DefType 794624 22 CMetaInterval::DefType 22 CMetaInterval::DefType 327 0 0 0 0 0 0 0 0 0 4 13 DT_c_interval 28 CMetaInterval::DT_c_interval 0 12 DT_ext_index 27 CMetaInterval::DT_ext_index 1 13 DT_push_level 28 CMetaInterval::DT_push_level 2 12 DT_pop_level 27 CMetaInterval::DT_pop_level 3 0 0

330 12 HideInterval 141313 12 HideInterval 12 HideInterval 0 0 0 1 303 305 0 1 304 0 0 1 0 312 0 0 0 0 225
////////////////////////////////////////////////////////////////////
//       Class : HideInterval
// Description : An interval that calls NodePath::hide().
////////////////////////////////////////////////////////////////////

331 12 ShowInterval 141313 12 ShowInterval 12 ShowInterval 0 0 0 1 306 308 0 1 307 0 0 1 0 312 0 0 0 0 225
////////////////////////////////////////////////////////////////////
//       Class : ShowInterval
// Description : An interval that calls NodePath::show().
////////////////////////////////////////////////////////////////////

332 12 WaitInterval 141313 12 WaitInterval 12 WaitInterval 0 0 0 1 309 311 0 1 310 0 0 1 0 312 0 0 0 0 338
////////////////////////////////////////////////////////////////////
//       Class : WaitInterval
// Description : This interval does absolutely nothing, and is mainly
//               useful for marking time between other intervals
//               within a sequence.
////////////////////////////////////////////////////////////////////

333 17 CInterval const * 8576 17 CInterval const * 17 CInterval const * 0 0 334 0 0 0 0 0 0 0 0 0 0

334 15 CInterval const 8832 15 CInterval const 15 CInterval const 0 0 312 0 0 0 0 0 0 0 0 0 0

335 13 atomic string 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

336 6 double 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

337 11 CInterval * 8576 11 CInterval * 11 CInterval * 0 0 312 0 0 0 0 0 0 0 0 0 0

338 4 void 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

339 18 CIntervalManager * 8576 18 CIntervalManager * 18 CIntervalManager * 0 0 322 0 0 0 0 0 0 0 0 0 0

340 9 ostream * 8576 9 ostream * 9 ostream * 0 0 341 0 0 0 0 0 0 0 0 0 0

341 7 ostream 2048 7 ostream 7 ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

342 3 int 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

343 10 TypeHandle 2048 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 1098
////////////////////////////////////////////////////////////////////
//       Class : TypeHandle
// Description : TypeHandle is the identifier used to differentiate
//               C++ class types.  Any C++ classes that inherit from
//               some base class, and must be differentiated at run
//               time, should store a static TypeHandle object that
//               can be queried through a static member function
//               named get_class_type().  Most of the time, it is also
//               desirable to inherit from TypedObject, which provides
//               some virtual functions to return the TypeHandle for a
//               particular instance.
//
//               At its essence, a TypeHandle is simply a unique
//               identifier that is assigned by the TypeRegistry.  The
//               TypeRegistry stores a tree of TypeHandles, so that
//               ancestry of a particular type may be queried, and the
//               type name may be retrieved for run-time display.
////////////////////////////////////////////////////////////////////

344 12 TypeHandle * 8576 12 TypeHandle * 12 TypeHandle * 0 0 343 0 0 0 0 0 0 0 0 0 0

345 27 CConstraintInterval const * 8576 27 CConstraintInterval const * 27 CConstraintInterval const * 0 0 346 0 0 0 0 0 0 0 0 0 0

346 25 CConstraintInterval const 8832 25 CConstraintInterval const 25 CConstraintInterval const 0 0 316 0 0 0 0 0 0 0 0 0 0

347 21 CConstraintInterval * 8576 21 CConstraintInterval * 21 CConstraintInterval * 0 0 316 0 0 0 0 0 0 0 0 0 0

348 16 NodePath const * 8576 16 NodePath const * 16 NodePath const * 0 0 349 0 0 0 0 0 0 0 0 0 0

349 14 NodePath const 8832 14 NodePath const 14 NodePath const 0 0 350 0 0 0 0 0 0 0 0 0 0

350 8 NodePath 2048 8 NodePath 8 NodePath 0 0 0 0 0 0 0 2 397 398 0 0 0 0 4938
//
// A NodePath is the fundamental unit of high-level interaction with
// the scene graph.  It encapsulates the complete path down to a node
// from some other node, usually the root of the scene graph.  This is
// used to resolve ambiguities associated with instancing.
//
// NodePath also contains a number of handy high-level methods for
// common scene-graph manipulations, such as reparenting, and common
// state changes, such as repositioning.
//
// There are also a number of NodePath methods for finding nodes deep
// within the tree by name or by type.  These take a path string,
// which at its simplest consists of a series of node names separated
// by slashes, like a directory pathname.
//
// Each component of the path string may optionally consist of one of
// the following special names, instead of a node name:
//
//   *          -- matches exactly one node, with any name.
//   **         -- matches any sequence of zero or more nodes.
//   +typename  -- matches any node that is or derives from the given type.
//   -typename  -- matches any node that is the given type exactly.
//   =tag       -- matches any node that has the indicated tag.
//   =tag=value -- matches any node whose tag matches the indicated value.
//
// Furthermore, a node name may itself contain standard filename
// globbing characters, like *, ?, and [a-z], that will be accepted as
// a partial match.  (In fact, the '*' special name may be seen as
// just a special case of this.)  The globbing characters may not be
// used with the typename matches or with tag matches, but they may
// be used to match a tag's value in the =tag=value syntax.
//
// The special characters "@@", appearing at the beginning of a node
// name, indicate a stashed node.  Normally, stashed nodes are not
// returned by a find (but see the special flags, below), but a
// stashed node may be found if it is explicitly named with its
// leading @@ characters.  By extension, "@@*" may be used to identify
// any stashed node.
//
// Examples:
//
// "room//graph" will look for a node named "graph", which is a child
// of an unnamed node, which is a child of a node named "room", which
// is a child of the starting path.
//
// "**/red*" will look for any node anywhere in the tree (below the
// starting path) with a name that begins with "red".
//
// "**/+PartBundleNode/**/head" will look for a node named "head",
// somewhere below a PartBundleNode anywhere in the tree.
//
//
// The search is always potentially ambiguous, even if the special
// wildcard operators are not used, because there may be multiple
// nodes in the tree with the same name.  In general, in the case of
// an ambiguity, the shortest path is preferred; when a method (such
// as extend_by) must choose only only one of several possible paths,
// it will choose the shortest available; on the other hand, when a
// method (such as find_all_matches) is to return all of the matching
// paths, it will sort them so that the shortest paths appear first in
// the output.
//
//
// Special flags.  The entire string may optionally be followed by the
// ";" character, followed by one or more of the following special
// control flags, with no intervening spaces or punctuation:
//
//    -h    Do not return hidden nodes.
//    +h    Do return hidden nodes.
//    -s    Do not return stashed nodes unless explicitly referenced with @@.
//    +s    Return stashed nodes even without any explicit @@ characters.
//    -i    Node name comparisons are not case insensitive: case must match
//          exactly.
//    +i    Node name comparisons are case insensitive: case is not important.
//          This affects matches against the node name only; node type
//          and tag strings are always case sensitive.
//
// The default flags are +h-s-i.
//
////////////////////////////////////////////////////////////////////
//       Class : NodePath
// Description : NodePath is the fundamental system for disambiguating
//               instances, and also provides a higher-level interface
//               for manipulating the scene graph.
//
//               A NodePath is a list of connected nodes from the root
//               of the graph to any sub-node.  Each NodePath
//               therefore uniquely describes one instance of a node.
//
//               NodePaths themselves are lightweight objects that may
//               easily be copied and passed by value.  Their data is
//               stored as a series of NodePathComponents that are
//               stored on the nodes.  Holding a NodePath will keep a
//               reference count to all the nodes in the path.
//               However, if any node in the path is removed or
//               reparented (perhaps through a different NodePath),
//               the NodePath will automatically be updated to reflect
//               the changes.
////////////////////////////////////////////////////////////////////

351 18 LVecBase3f const * 8576 18 LVecBase3f const * 18 LVecBase3f const * 0 0 352 0 0 0 0 0 0 0 0 0 0

352 16 LVecBase3f const 8832 16 LVecBase3f const 16 LVecBase3f const 0 0 353 0 0 0 0 0 0 0 0 0 0

353 9 RGBColorf 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 754
// Filename: lvecBase3_src.h
// Created by:  drose (08Mar00)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//       Class : LVecBase3
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

354 23 CConstrainHprInterval * 8576 23 CConstrainHprInterval * 23 CConstrainHprInterval * 0 0 318 0 0 0 0 0 0 0 0 0 0

355 29 CConstrainHprInterval const * 8576 29 CConstrainHprInterval const * 29 CConstrainHprInterval const * 0 0 356 0 0 0 0 0 0 0 0 0 0

356 27 CConstrainHprInterval const 8832 27 CConstrainHprInterval const 27 CConstrainHprInterval const 0 0 318 0 0 0 0 0 0 0 0 0 0

357 26 CConstrainPosHprInterval * 8576 26 CConstrainPosHprInterval * 26 CConstrainPosHprInterval * 0 0 319 0 0 0 0 0 0 0 0 0 0

358 32 CConstrainPosHprInterval const * 8576 32 CConstrainPosHprInterval const * 32 CConstrainPosHprInterval const * 0 0 359 0 0 0 0 0 0 0 0 0 0

359 30 CConstrainPosHprInterval const 8832 30 CConstrainPosHprInterval const 30 CConstrainPosHprInterval const 0 0 319 0 0 0 0 0 0 0 0 0 0

360 23 CConstrainPosInterval * 8576 23 CConstrainPosInterval * 23 CConstrainPosInterval * 0 0 320 0 0 0 0 0 0 0 0 0 0

361 29 CConstrainPosInterval const * 8576 29 CConstrainPosInterval const * 29 CConstrainPosInterval const * 0 0 362 0 0 0 0 0 0 0 0 0 0

362 27 CConstrainPosInterval const 8832 27 CConstrainPosInterval const 27 CConstrainPosInterval const 0 0 320 0 0 0 0 0 0 0 0 0 0

363 29 CConstrainTransformInterval * 8576 29 CConstrainTransformInterval * 29 CConstrainTransformInterval * 0 0 321 0 0 0 0 0 0 0 0 0 0

364 35 CConstrainTransformInterval const * 8576 35 CConstrainTransformInterval const * 35 CConstrainTransformInterval const * 0 0 365 0 0 0 0 0 0 0 0 0 0

365 33 CConstrainTransformInterval const 8832 33 CConstrainTransformInterval const 33 CConstrainTransformInterval const 0 0 321 0 0 0 0 0 0 0 0 0 0

366 12 EventQueue * 8576 12 EventQueue * 12 EventQueue * 0 0 367 0 0 0 0 0 0 0 0 0 0

367 10 EventQueue 2048 10 EventQueue 10 EventQueue 0 0 0 0 0 0 0 0 0 0 0 0 392
////////////////////////////////////////////////////////////////////
//       Class : EventQueue
// Description : A queue of pending events.  As events are thrown,
//               they are added to this queue; eventually, they will
//               be extracted out again by an EventHandler and
//               processed.
////////////////////////////////////////////////////////////////////

368 24 CIntervalManager const * 8576 24 CIntervalManager const * 24 CIntervalManager const * 0 0 369 0 0 0 0 0 0 0 0 0 0

369 22 CIntervalManager const 8832 22 CIntervalManager const 22 CIntervalManager const 0 0 322 0 0 0 0 0 0 0 0 0 0

370 21 CLerpInterval const * 8576 21 CLerpInterval const * 21 CLerpInterval const * 0 0 371 0 0 0 0 0 0 0 0 0 0

371 19 CLerpInterval const 8832 19 CLerpInterval const 19 CLerpInterval const 0 0 323 0 0 0 0 0 0 0 0 0 0

372 25 CLerpAnimEffectInterval * 8576 25 CLerpAnimEffectInterval * 25 CLerpAnimEffectInterval * 0 0 325 0 0 0 0 0 0 0 0 0 0

373 13 AnimControl * 8576 13 AnimControl * 13 AnimControl * 0 0 374 0 0 0 0 0 0 0 0 0 0

374 11 AnimControl 2048 11 AnimControl 11 AnimControl 0 0 0 0 0 0 0 0 0 0 0 0 487
////////////////////////////////////////////////////////////////////
//       Class : AnimControl
// Description : Controls the timing of a character animation.  An
//               AnimControl object is created for each
//               character/bundle binding and manages the state of the
//               animation: whether started, stopped, or looping, and
//               the current frame number and play rate.
////////////////////////////////////////////////////////////////////

375 5 float 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

376 23 CLerpNodePathInterval * 8576 23 CLerpNodePathInterval * 23 CLerpNodePathInterval * 0 0 326 0 0 0 0 0 0 0 0 0 0

377 29 CLerpNodePathInterval const * 8576 29 CLerpNodePathInterval const * 29 CLerpNodePathInterval const * 0 0 378 0 0 0 0 0 0 0 0 0 0

378 27 CLerpNodePathInterval const 8832 27 CLerpNodePathInterval const 27 CLerpNodePathInterval const 0 0 326 0 0 0 0 0 0 0 0 0 0

379 20 LQuaternionf const * 8576 20 LQuaternionf const * 20 LQuaternionf const * 0 0 380 0 0 0 0 0 0 0 0 0 0

380 18 LQuaternionf const 8832 18 LQuaternionf const 18 LQuaternionf const 0 0 381 0 0 0 0 0 0 0 0 0 0

381 12 LQuaternionf 2048 12 LQuaternionf 12 LQuaternionf 0 0 0 0 0 0 0 0 0 0 0 0 719
// Filename: lquaternion_src.h
// Created by:  frang (06Jun00)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//       Class : FLOATNAME(LQuaternion)
// Description : This is the base quaternion class
////////////////////////////////////////////////////////////////////

382 18 LVecBase4f const * 8576 18 LVecBase4f const * 18 LVecBase4f const * 0 0 383 0 0 0 0 0 0 0 0 0 0

383 16 LVecBase4f const 8832 16 LVecBase4f const 16 LVecBase4f const 0 0 384 0 0 0 0 0 0 0 0 0 0

384 6 Colorf 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 0 265
////////////////////////////////////////////////////////////////////
//       Class : LVecBase4
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

385 14 TextureStage * 8576 14 TextureStage * 14 TextureStage * 0 0 386 0 0 0 0 0 0 0 0 0 0

386 12 TextureStage 2048 12 TextureStage 12 TextureStage 0 0 0 0 0 0 0 0 0 0 0 0 600
////////////////////////////////////////////////////////////////////
//       Class : TextureStage
// Description : Defines the properties of a named stage of the
//               multitexture pipeline.  The TextureAttrib will
//               associated a number of these stages with Texture
//               objects, and the GSG will render geometry by sorting
//               all of the currently active TextureStages in order
//               and then issuing the appropriate rendering calls to
//               activate them.
////////////////////////////////////////////////////////////////////

387 18 LVecBase2f const * 8576 18 LVecBase2f const * 18 LVecBase2f const * 0 0 388 0 0 0 0 0 0 0 0 0 0

388 16 LVecBase2f const 8832 16 LVecBase2f const 16 LVecBase2f const 0 0 389 0 0 0 0 0 0 0 0 0 0

389 10 LVecBase2f 2048 10 LVecBase2f 10 LVecBase2f 0 0 0 0 0 0 0 0 0 0 0 0 805
// Filename: lvecBase2_src.h
// Created by:  drose (08Mar00)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
//typedef struct {FLOATTYPE _0, _1} FLOATNAME(data);
////////////////////////////////////////////////////////////////////
//       Class : LVecBase2
// Description : This is the base class for all two-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

390 15 CMetaInterval * 8576 15 CMetaInterval * 15 CMetaInterval * 0 0 327 0 0 0 0 0 0 0 0 0 0

391 21 CMetaInterval const * 8576 21 CMetaInterval const * 21 CMetaInterval const * 0 0 392 0 0 0 0 0 0 0 0 0 0

392 19 CMetaInterval const 8832 19 CMetaInterval const 19 CMetaInterval const 0 0 327 0 0 0 0 0 0 0 0 0 0

393 14 HideInterval * 8576 14 HideInterval * 14 HideInterval * 0 0 330 0 0 0 0 0 0 0 0 0 0

394 14 ShowInterval * 8576 14 ShowInterval * 14 ShowInterval * 0 0 331 0 0 0 0 0 0 0 0 0 0

395 14 WaitInterval * 8576 14 WaitInterval * 14 WaitInterval * 0 0 332 0 0 0 0 0 0 0 0 0 0

0
1
396 14 bogus_variable 6 317 204 205 35 CConstraintInterval::bogus_variable 
2
397 0 245 9 get_nodes 13 get_num_nodes 8 get_node 
398 0 245 13 get_ancestors 13 get_num_nodes 12 get_ancestor 
